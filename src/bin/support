#!/bin/sh
# Support utilities for troubleshooting Infix systems
#
# Usage: support <command> [options]
#
# Commands:
#   collect [--log-sec N]    Collect system information for support/troubleshooting
#   clean [--dry-run] [--days N]    Remove old support collection directories
#
# Options for collect:
#   --log-sec N        Tail /var/log/messages for N seconds (default: 30)
#
# Examples:
#   support collect > support-data.tar.gz
#   support collect --log-sec 5 > support-data.tar.gz
#   ssh user@device support collect > support-data.tar.gz
#   support clean --dry-run
#   support clean --days 30
#
# Installation (for older Infix versions without this script):
#   1. Copy this script to the target device's home directory:
#      scp support user@device:~/
#
#   2. SSH to the device and make it executable:
#      ssh user@device
#      chmod +x ~/support
#
#   3. Run the script from your home directory:
#      ~/support collect > support-data.tar.gz
#      # Or directly via SSH from your workstation:
#      ssh user@device '~/support collect' > support-data.tar.gz
#
# TODO:
#   Add more commands, e.g., verify (run health checks), upload <file>,
#   test <network|disk|routing>, backup, watch (dashboard view), diff
#

cmd_collect()
{
    # Default values
    LOG_TAIL_SEC=30

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            --log-sec)
                if [ -z "$2" ] || [ "$2" -le 0 ] 2>/dev/null; then
                    echo "Error: --log-sec requires a positive number" >&2
                    exit 1
                fi
                LOG_TAIL_SEC="$2"
                shift 2
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: support collect [--log-sec N]" >&2
                exit 1
                ;;
        esac
    done

    # Create unique collection directory in user's home directory
    # (avoids /tmp which may be full)
    COLLECT_DIR="${HOME}/support-$(hostname -s)-$(date -Iseconds)"
    EXEC_LOG="${COLLECT_DIR}/collection.log"

    # Cleanup on exit
    cleanup()
    {
        if [ -d "${COLLECT_DIR}" ]; then
            rm -rf "${COLLECT_DIR}"
        fi
    }
    trap cleanup EXIT INT TERM

    # Create collection directory
    mkdir -p "${COLLECT_DIR}"

    # Determine if we need sudo and if it's available
    SUDO=""
    if [ "$(id -u)" -ne 0 ]; then
        if command -v sudo >/dev/null 2>&1; then
            SUDO="sudo"
        fi
    fi

    # Helper function to run commands with output to specific file
    collect()
    {
        output_file="$1"
        shift
        cmd_desc="$*"

	mkdir -p "${COLLECT_DIR}/$(dirname "$output_file")"
        echo "[$(date -Iseconds)] Collecting: $cmd_desc -> ${output_file}" >> "${EXEC_LOG}" 2>&1
        if "$@" > "${COLLECT_DIR}/${output_file}" 2>> "${EXEC_LOG}"; then
            echo "[$(date -Iseconds)] Success: ${output_file}" >> "${EXEC_LOG}" 2>&1
        else
            exit_code=$?
            echo "[$(date -Iseconds)] Failed (exit ${exit_code}): ${output_file}" >> "${EXEC_LOG}" 2>&1
            # Create placeholder file indicating failure
            echo "Command failed with exit code ${exit_code}: $cmd_desc" > "${COLLECT_DIR}/${output_file}"
        fi
    }

    # Start collection log
    echo "=== Infix Support Data Collection ==="   > "${EXEC_LOG}"
    echo "Started: $(date -Iseconds)"             >> "${EXEC_LOG}"
    echo "Hostname: $(hostname)"                  >> "${EXEC_LOG}"
    echo "Collection directory: ${COLLECT_DIR}"   >> "${EXEC_LOG}"
    echo ""                                       >> "${EXEC_LOG}"

    # Inform user that collection is starting (to stderr for SSH visibility)
    echo "Starting support data collection from $(hostname)..." >&2
    echo "This may take up to a minute. Please wait..." >&2

    # System identification
    collect system-info.txt uname -a
    collect hostname.txt hostname
    collect uptime.txt uptime

    # Configuration files
    collect running-config.json sysrepocfg -f json -d running -X
    collect operational-config.json sysrepocfg -f json -d operational -X

    # Sysrepo YANG modules
    if command -v sysrepoctl >/dev/null 2>&1; then
        collect sysrepo-modules.txt sysrepoctl -l
    fi

    # Startup config (may not exist on first boot)
    if [ -f /cfg/startup-config.cfg ]; then
        cp /cfg/startup-config.cfg "${COLLECT_DIR}/startup-config.cfg" 2>> "${EXEC_LOG}"
    else
        echo "No startup-config.cfg found" > "${COLLECT_DIR}/startup-config.cfg"
    fi

    # System logs and runtime data
    if [ -d /var/log ]; then
        if ls -A /var/log >/dev/null 2>&1; then
            tar czf "${COLLECT_DIR}/logs.tar.gz" -C / var/log 2>> "${EXEC_LOG}" || \
                echo "Failed to collect /var/log" > "${COLLECT_DIR}/logs.tar.gz.error"
        else
            echo "No logs in /var/log" > "${COLLECT_DIR}/logs.tar.gz.error"
        fi
    fi

    # Collect crash dumps if they exist
    if [ -d /var/crash ]; then
        if ls -A /var/crash >/dev/null 2>&1; then
            tar czf "${COLLECT_DIR}/crash.tar.gz" -C / var/crash 2>> "${EXEC_LOG}" || \
                echo "Failed to collect /var/crash" > "${COLLECT_DIR}/crash.tar.gz.error"
        else
            echo "No crash dumps in /var/crash" > "${COLLECT_DIR}/crash.tar.gz.error"
        fi
    fi

    # Tail /var/log/messages to capture live logging
    if [ -f /var/log/messages ]; then
        echo "Tailing /var/log/messages for ${LOG_TAIL_SEC} seconds (please wait)..." >&2
        {
            echo "=== Starting tail of /var/log/messages for ${LOG_TAIL_SEC} seconds ==="
            timeout "${LOG_TAIL_SEC}" tail -F /var/log/messages 2>/dev/null || true
            echo ""
            echo "=== End of ${LOG_TAIL_SEC}-second tail ==="
        } > "${COLLECT_DIR}/logs-tail-${LOG_TAIL_SEC}s.txt" 2>> "${EXEC_LOG}"
        echo "Log tail complete." >&2
    fi

    if [ -d /run/net ]; then
        if ls -A /run/net >/dev/null 2>&1; then
            tar czf "${COLLECT_DIR}/run-net.tar.gz" -C / run/net 2>> "${EXEC_LOG}" || \
                echo "Failed to collect /run/net" > "${COLLECT_DIR}/run-net.tar.gz.error"
        else
            echo "No data in /run/net" > "${COLLECT_DIR}/run-net.tar.gz.error"
        fi
    fi

    if [ -d /run/finit ]; then
        if ls -A /run/finit >/dev/null 2>&1; then
            tar czf "${COLLECT_DIR}/run-finit.tar.gz" -C / run/finit 2>> "${EXEC_LOG}" || \
                echo "Failed to collect /run/finit" > "${COLLECT_DIR}/run-finit.tar.gz.error"
        else
            echo "No data in /run/finit" > "${COLLECT_DIR}/run-finit.tar.gz.error"
        fi
    fi

    # Kernel and system state
    collect system/dmesg.txt    ${SUDO} dmesg
    collect system/free.txt     free -h
    collect system/stat.txt     cat /proc/stat
    collect system/softirqs.txt cat /proc/softirqs
    collect system/locks.txt    cat /proc/locks
    collect system/meminfo.txt  cat /proc/meminfo
    collect system/file-nr.txt  cat /proc/sys/fs/file-nr
    collect system/ps.txt       ps -o pid,rss,comm
    collect system/df.txt       df -h

    # Finit/init state
    if command -v initctl >/dev/null 2>&1; then
        collect initctl/cgroup.txt initctl cgroup
        collect initctl/status.txt initctl status
    fi

    # CPU statistics
    if command -v mpstat >/dev/null 2>&1; then
        collect system/mpstat.txt mpstat -P ALL 1 1
    else
        echo "mpstat not available" > "${COLLECT_DIR}/mpstat.txt"
    fi

    # Top output (two samples)
    collect system/top.txt sh -c 'top -b -n 2 -d 2'

    # Interrupt statistics (before and after 2 second delay)
    collect system/interrupts1.txt cat /proc/interrupts
    sleep 2
    collect system/interrupts2.txt cat /proc/interrupts

    # Network information
    collect network/ip/addr.txt  ip -s -d -j addr  show
    collect network/ip/route.txt ip -s -d -j route show
    collect network/ip/link.txt  ip -s -d -j link  show
    collect network/ip/neigh.txt ip -s -d -j neigh show
    collect network/ifconfig.txt ifconfig -a

    # Collect ethtool information for all ethernet interfaces
    if command -v ethtool >/dev/null 2>&1; then
        # Get list of ethernet interfaces (any interface with link/ether)
        ip -o link show | grep 'link/ether' | awk -F': ' '{print $2}' > "${COLLECT_DIR}/.iface-list" 2>> "${EXEC_LOG}"
        if [ -s "${COLLECT_DIR}/.iface-list" ]; then
            while IFS= read -r iface; do
                # ethtool typically needs root/sudo
                collect "network/ethtool/${iface}.txt"       ${SUDO} ethtool "$iface"
                collect "network/ethtool/stats-${iface}.txt" ${SUDO} ethtool -S "$iface"
                collect "network/ethtool/module-${iface}.txt" ${SUDO} ethtool -m "$iface"
            done < "${COLLECT_DIR}/.iface-list"
        fi
        rm -f "${COLLECT_DIR}/.iface-list"
    fi

    if command -v bridge >/dev/null 2>&1; then
        collect network/bridge/link.txt bridge -d -s -j link show
        collect network/bridge/fdb.txt bridge -d -s -j fdb show
    fi

    # Firewall rules
    if command -v nft >/dev/null 2>&1; then
        collect network/nftables.txt ${SUDO} nft list ruleset
    fi

    # FRR routing information
    if command -v vtysh >/dev/null 2>&1; then
        collect frr/running-config.txt  vtysh -c "show running-config"
        collect frr/ip-route.txt        vtysh -c "show ip route"
        collect frr/ospf-interfaces.txt vtysh -c "show ip ospf interfaces"
        collect frr/ospf-neighbor.txt   vtysh -c "show ip ospf neighbor"
        collect frr/ospf-routes.txt     vtysh -c "show ip ospf routes"
        collect frr/bgp-summary.txt     vtysh -c "show ip bgp summary"
        collect frr/bfd-peers.txt       vtysh -c "show bfd peers"
    fi

    # Container information
    if command -v podman >/dev/null 2>&1; then
        # List all containers
        collect podman/ps.txt podman ps -a

        # Collect podman system info
        collect podman/info.json podman info --format=json

        # Get list of containers and inspect each
        if podman ps -a --format '{{.Names}}' > "${COLLECT_DIR}/.container-list" 2>> "${EXEC_LOG}"; then
            while IFS= read -r container; do
                if [ -n "$container" ]; then
                    safe_name=$(echo "$container" | tr '/' '_')
                    collect "podman/inspect-${safe_name}.json" podman inspect "$container"
                fi
            done < "${COLLECT_DIR}/.container-list"
            rm -f "${COLLECT_DIR}/.container-list"
        fi
    fi

    # Additional system information
    collect system/lsmod.txt lsmod
    if command -v lspci >/dev/null 2>&1; then
        collect system/lspci.txt lspci -v
    else
        echo "lspci not available" > "${COLLECT_DIR}/lspci.txt"
    fi

    if command -v lsusb >/dev/null 2>&1; then
        collect system/lsusb.txt lsusb -v
    else
        echo "lsusb not available" > "${COLLECT_DIR}/lsusb.txt"
    fi

    # Disk I/O stats
    if command -v iostat >/dev/null 2>&1; then
        collect system/iostat.txt iostat -x 1 2
    else
        echo "iostat not available" > "${COLLECT_DIR}/iostat.txt"
    fi

    # Process resource usage
    if command -v pstree >/dev/null 2>&1; then
        collect system/pstree.txt pstree -p
    else
        collect system/pstree.txt ps fax
    fi

    # Environment and versions
    collect system/env.txt env

    # Network sockets
    if command -v netstat >/dev/null 2>&1; then
        collect system/netstat.txt netstat -tunlp
    else
        collect system/netstat.txt ss -tunlp
    fi

    # Completion timestamp in log
    echo "" >> "${EXEC_LOG}"
    echo "Completed: $(date -Iseconds)" >> "${EXEC_LOG}"

    # Notify user that collection is done
    echo "Collection complete. Creating archive..." >&2

    # Create final tar.gz and output to stdout
    # Use -C to change to parent directory so paths in archive don't include full home path
    cd "${HOME}"
    tar czf - "$(basename "${COLLECT_DIR}")" 2>> "${EXEC_LOG}"
}

cmd_clean()
{
    dry_run=0
    days=7

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run|-n)
                dry_run=1
                shift
                ;;
            --days|-d)
                if [ -z "$2" ] || [ "$2" -le 0 ] 2>/dev/null; then
                    echo "Error: --days requires a positive number" >&2
                    exit 1
                fi
                days="$2"
                shift 2
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                echo "Usage: support clean [--dry-run] [--days N]" >&2
                exit 1
                ;;
        esac
    done

    # Find support collection directories in user's home
    pattern="${HOME}/support-20*"
    found=0
    total_size=0

    if [ "$dry_run" -eq 1 ]; then
        echo "Dry run - no files will be deleted"
        echo ""
    fi

    echo "Looking for support directories older than ${days} days..."
    echo ""

    # Use find to locate old support directories
    # The pattern matches: support-YYYY-MM-DD* format
    if [ -d "${HOME}" ]; then
        find "${HOME}" -maxdepth 1 -type d -name "support-20*" -mtime "+${days}" 2>/dev/null | while IFS= read -r dir; do
            found=1
            size=$(du -sh "$dir" 2>/dev/null | awk '{print $1}')
            mtime=$(stat -c %y "$dir" 2>/dev/null | cut -d' ' -f1)

            if [ "$dry_run" -eq 1 ]; then
                echo "Would remove: $dir ($size, modified: $mtime)"
            else
                echo "Removing: $dir ($size, modified: $mtime)"
                rm -rf "$dir"
            fi
        done

        # Check if we found anything (find runs in subshell, so we check differently)
        count=$(find "${HOME}" -maxdepth 1 -type d -name "support-20*" -mtime "+${days}" 2>/dev/null | wc -l)

        if [ "$count" -eq 0 ]; then
            echo "No support directories older than ${days} days found."
        elif [ "$dry_run" -eq 1 ]; then
            echo ""
            echo "Found ${count} directories. Run without --dry-run to remove them."
        else
            echo ""
            echo "Removed ${count} directories."
        fi
    fi
}

usage()
{
    echo "Usage: support <command> [options]"
    echo ""
    echo "Commands:"
    echo "  collect              Collect system information for support/troubleshooting"
    echo "                       NOTE: may take up to a minute to finish, please wait!"
    echo "  clean [options]      Remove old support collection directories"
    echo ""
    echo "Options for clean:"
    echo "  --dry-run, -n        Show what would be deleted without deleting"
    echo "  --days N, -d N       Remove directories older than N days (default: 7)"
    echo ""
    echo "Examples:"
    echo "  support collect > support-data.tar.gz"
    echo "  ssh user@device support collect > support-data.tar.gz"
    echo "  support clean --dry-run"
    echo "  support clean --days 30"
    exit 1
}

# Main command dispatcher
if [ $# -lt 1 ]; then
    usage
fi

command="$1"
shift

case "$command" in
    collect)
        cmd_collect "$@"
        ;;
    clean)
        cmd_clean "$@"
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo "Error: Unknown command '$command'" >&2
        echo "" >&2
        usage
        ;;
esac
