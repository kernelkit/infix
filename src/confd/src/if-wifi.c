/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>

#include "interfaces.h"

#define WPA_SUPPLICANT_FINIT_CONF "/etc/finit.d/available/wpa_supplicant-%s.conf"
#define WPA_SUPPLICANT_CONF       "/etc/wpa_supplicant-%s.conf"
#define HOSTAPD_SUPPLICANT_CONF   "/etc/hostapd-%s.conf"

struct lyd_node *wifi_ap_get_radio(struct lyd_node *cif) {
	struct lyd_node *wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		const char *radio = lydx_get_cattr(wifi, "radio");
		if (radio) {
			struct lyd_node *radio_if = lydx_get_xpathf(cif, "../interface[name='%s']", radio);
			if (radio_if)
				return radio_if;
		}
	}
	return NULL;
}
static int wifi_gen_station_config(const char *ifname, const char *ssid, const char *country, const char *secret, const char* encryption, struct dagger *net, int counter)
{
	FILE *wpa_supplicant = NULL, *wpa = NULL;
	char *encryption_str;
	int rc = SR_ERR_OK;

	if (!secret && (ssid && encryption)) {
		/* Not an error, updated from two ways, interface cb and keystore cb. */
		return 0;
	}

	wpa = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "wpa_supplicant.sh");
	if (!wpa) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	fprintf(wpa, "# Generated by Infix confd\n");

	fprintf(wpa, "if [ -f '/etc/finit.d/enabled/wifi@%s.conf' ];then\n", ifname);
	fprintf(wpa, "initctl -bfqn touch wifi@%s\n", ifname);
	fprintf(wpa, "else\n");
	fprintf(wpa, "initctl -bfqn enable wifi@%s\n", ifname);
	fprintf(wpa, "fi\n");
	fclose(wpa);

	wpa_supplicant = fopenf("w", WPA_SUPPLICANT_CONF, ifname);
	if (!wpa_supplicant) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	if (!ssid || !secret) {
		fprintf(wpa_supplicant,
			"ctrl_interface=/run/wpa_supplicant\n"
			"autoscan=periodic:10\n"
			"ap_scan=1\n");
	} else {
		if (!strcmp(encryption, "disabled")) {
			asprintf(&encryption_str, "key_mgmt=NONE");
		} else {
			asprintf(&encryption_str, "key_mgmt=SAE WPA-PSK\npsk=\"%s\"", secret);
		}
		if (!counter) { /* First SSID */
			fprintf(wpa_supplicant,
				"country=%s\n"
				"ctrl_interface=/run/wpa_supplicant\n"
				"autoscan=periodic:10\n"
				"ap_scan=1\n\n", country);
		}
		fprintf(wpa_supplicant, "network={\n"
			"bgscan=\"simple: 30:-45:300\"\n"
			"ssid=\"%s\"\n"
			"%s\n"
			"}\n\n", ssid, encryption_str);
		free(encryption_str);
	}
	fclose(wpa_supplicant);

out:
	return rc;

}
static void disable_wifi_station(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "iw dev %s disconnect\n", ifname);
	fprintf(fp, "initctl -bfqn disable wifi@%s\n", ifname);
	erasef(WPA_SUPPLICANT_CONF, ifname);
}

static void disable_wifi_ap(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "initctl -bfqn disable hostapd@%s\n", ifname);
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);
}
int wifi_gen(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net) {
	struct lyd_node *cwifi, *dwifi = NULL, *cmode, *dmode = NULL;
	const char *ifname = lydx_get_cattr(cif, "name");
	FILE *fp;
	cwifi = lydx_get_child(cif, "wifi");
	if (!cwifi)
		return SR_ERR_OK;
        cmode = lydx_get_child(cwifi, "mode");

	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");
	if (dif) {
		dwifi = lydx_get_child(dif, "wifi");
		if (dwifi)
			dmode = lydx_get_child(dwifi, "mode");
	}
	if (!lydx_get_cattr(cif, "enabled")) {
		if (dwifi) {
			if (dmode && !strcmp(lyd_get_value(dmode), "accesspoint"))
				disable_wifi_ap(ifname, fp);
			else
				disable_wifi_station(ifname, fp);
		}
		goto out;
	}

	if (cmode && !strcmp(lyd_get_value(cmode), "accesspoint")) {
		if (dmode && strcmp(lyd_get_value(dmode), "accesspoint"))
			disable_wifi_station(ifname, fp);
		wifi_ap_gen(cif, net);

	} else {
		if (dmode && strcmp(lyd_get_value(dmode), "station"))
			disable_wifi_ap(ifname, fp);
		/* Client */
		wifi_station_gen(cif, net);
	}
out:
	fclose(fp);
	return SR_ERR_OK;
}
int wifi_station_gen(struct lyd_node *cif, struct dagger *net)
{
	const char *ssid_name, *secret_name, *secret = NULL, *ifname, *country;
	const char *encryption, *mode;
	struct lyd_node *wifi, *secret_node;
	bool enabled;
        int counter = 0;
	FILE *fp;

	ifname      = lydx_get_cattr(cif, "name");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");

	if (!fp) {
		ERROR("Could not open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	enabled     = lydx_get_bool(cif, "enabled");
	wifi        = lydx_get_child(cif, "wifi");

	if (!enabled || !wifi) {
	        disable_wifi_station(ifname, fp);
		goto out;
	}

	mode = lydx_get_cattr(wifi, "mode");
	if (mode && !strcmp(mode, "accesspoint")) {
		/* Interface is in access point mode - handle radio setup */
		disable_wifi_station(ifname, fp);
		fclose(fp);
		return wifi_ap_gen(cif, net);
	}

	/* Clean up any existing station configuration */
	erasef(WPA_SUPPLICANT_CONF, ifname);

	country = lydx_get_cattr(wifi, "country-code");
	if (!country)
		country = "00";

	if (!lydx_get_child(wifi, "ssid")) {
		/* Only the presence container is set - radio only, no station connection */
		wifi_gen_station_config(ifname, NULL, country, NULL, NULL, net, 0);
		goto out;
	}

	ssid_name   = lydx_get_cattr(wifi, "ssid");
	secret_name = lydx_get_cattr(wifi, "secret");
	encryption  = lydx_get_cattr(wifi, "encryption");
	if (secret_name) {
		secret_node = lydx_get_xpathf(cif, "../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
		secret      = lydx_get_cattr(secret_node, "cleartext-key");
	}
	wifi_gen_station_config(ifname, ssid_name, country, secret, encryption, net, counter);
	counter++;

out:
	fclose(fp);
	return SR_ERR_OK;
}

int wifi_ap_del_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname;
	FILE *iw;

	ifname = lydx_get_cattr(cif, "name");
	iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT, "exit-iw.sh");

	fprintf(iw, "# Check if interface has altname, if so restore it, else delete interface\n");
	fprintf(iw, "ALTNAME=$(ip -j link show dev %s | jq -r '.[0].altnames[0] // empty')\n", ifname);
	fprintf(iw, "if [ -n \"$ALTNAME\" ]; then\n");
	fprintf(iw, "  # Restore original radio name\n");
	fprintf(iw, "  ip link set dev %s name \"$ALTNAME\"\n", ifname);
	fprintf(iw, "  ip link property del dev \"$ALTNAME\" altname \"$ALTNAME\"\n");
	fprintf(iw, "else\n");
	fprintf(iw, "  # Delete virtual AP interface\n");
	fprintf(iw, "  iw dev %s del\n", ifname);
	fprintf(iw, "fi\n");

	fclose(iw);

	return 0;
}

int wifi_ap_add_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	FILE *iw;

	ifname = lydx_get_cattr(cif, "name");

	wifi = lydx_get_child(cif, "wifi");
	if (!wifi) {
		ERROR("wifi-ap interface %s missing wifi configuration", ifname);
		return SR_ERR_INVAL_ARG;
	}

	radio = lydx_get_cattr(wifi, "radio");
	if (!radio) {
		ERROR("wifi-ap interface %s missing radio reference", ifname);
		return SR_ERR_INVAL_ARG;
	}

	dagger_add_dep(&confd.netdag, ifname, radio);
	iw = dagger_fopen_net_init(net, ifname, NETDAG_INIT_PRE, "init-iw.sh");

	fprintf(iw, "# Check if radio has altname, if so create virtual interface, else rename radio\n");
	fprintf(iw, "ALTNAME=$(ip -j link show dev %s | jq -r '.[0].altnames[0] // empty')\n", radio);
	fprintf(iw, "if [ -n \"$ALTNAME\" ]; then\n");
	fprintf(iw, "  # Radio already renamed, create virtual AP interface\n");
	fprintf(iw, "  logger -t confd -p daemon.info \"Creating virtual AP interface %s on radio %s\"\n", ifname, radio);
	fprintf(iw, "  iw dev %s interface add %s type __ap\n", radio, ifname);
	fprintf(iw, "else\n");
	fprintf(iw, "  # First AP interface, rename radio to AP name\n");
	fprintf(iw, "  logger -t confd -p daemon.info \"Renaming radio %s to AP interface %s\"\n", radio, ifname);
	fprintf(iw, "  ip link set dev %s down\n", radio);
	fprintf(iw, "  ip link set dev %s name %s\n", radio, ifname);
	fprintf(iw, "  ip link property add dev %s altname %s\n", ifname, radio);
	fprintf(iw, "fi\n");

	fclose(iw);

	return 0;
}

int wifi_is_accesspoint(struct lyd_node *cif) {
	struct lyd_node *wifi;
	const char *mode;

	wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		mode = lydx_get_cattr(wifi, "mode");
		ERROR("Accesspoint?: %d", !!strcmp(mode, "accesspoint"));
		if (mode)
			return !!strcmp(mode, "accesspoint");
	}
	ERROR("NOT ACCESSPOINT");
	return 0;
}
int wifi_ap_gen(struct lyd_node *cif, struct dagger *net)
{
	struct lyd_node *wifi, *ap_interface;
	struct ly_set *ap_interfaces = NULL;
	FILE *hostapd_conf, *hostapd_finit;
	const char *country, *band, *channel, *ifname;
	const char *main_interface_name;
	bool freq_24GHz;
	int rc = SR_ERR_OK;

	ERROR("GENERATE AP");
	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	country = lydx_get_cattr(wifi, "country-code");
	band = lydx_get_cattr(wifi, "band");
	channel = lydx_get_cattr(wifi, "channel");
	freq_24GHz = !strcmp(band, "2.4GHz");

	if (!channel || !strcmp(channel, "auto"))
		channel = freq_24GHz ? "6" : "149";

	ERROR("Searching radio");
	/* Find all wifi-ap interfaces that reference this radio */
	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/name]", &ap_interfaces);
	if (rc != LY_SUCCESS || !ap_interfaces || ap_interfaces->count == 0) {
		ERROR("No wifi-ap interfaces reference radio %s", ifname);
		return SR_ERR_OK;
	}

	/* The first AP interface becomes the main interface (radio gets renamed to this) */
	ap_interface = ap_interfaces->dnodes[0];
	main_interface_name = lydx_get_cattr(ap_interface, "name");

	ERROR("Generating hostapd config for radio %s, main interface %s with %d total APs",
		  ifname, ifname, ap_interfaces->count);

	/* Clean up any existing AP configuration */
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);

	hostapd_conf = fopenf("w", HOSTAPD_SUPPLICANT_CONF, ifname);
	if (!hostapd_conf) {
		ly_set_free(ap_interfaces, NULL);
		return SR_ERR_INTERNAL;
	}

	fprintf(hostapd_conf, "# Generated by Infix confd for radio %s (main interface %s)\n",
			ifname, main_interface_name);

	/* Basic hostapd configuration using the main AP interface name */
	fprintf(hostapd_conf,
		"interface=%s\n"
		"driver=nl80211\n"
		"hw_mode=%c\n"
		"wmm_enabled=1\n"
		"channel=%s\n"
		"logger_syslog=-1\n"
		"logger_syslog_level=0\n"
		"logger_stdout=0\n"
		"ctrl_interface=/var/run/hostapd\n"
		"ctrl_interface_group=0\n\n",
		main_interface_name, freq_24GHz ? 'g' : 'a', channel);

	if (strcmp(country, "00"))
		fprintf(hostapd_conf, "country_code=%s\n", country);

	if (freq_24GHz)
		fprintf(hostapd_conf, "ieee80211n=1\n");
	else
		fprintf(hostapd_conf, "ieee80211ac=1\n");

	/* Configure first AP interface as main SSID */
	struct lyd_node *main_wifi = lydx_get_child(ap_interface, "wifi");
	if (main_wifi) {
		const char *ssid = lydx_get_cattr(main_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(main_wifi, "secret");
		const char *encryption = lydx_get_cattr(main_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
		}

		fprintf(hostapd_conf, "\n# Main SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	/* Add additional AP interfaces as BSS entries */
	for (uint32_t i = 1; i < ap_interfaces->count; i++) {
		ap_interface = ap_interfaces->dnodes[i];
		const char *ap_ifname = lydx_get_cattr(ap_interface, "name");
		struct lyd_node *ap_wifi = lydx_get_child(ap_interface, "wifi");

		if (!ap_wifi) continue;

		const char *ssid = lydx_get_cattr(ap_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(ap_wifi, "secret");
		const char *encryption = lydx_get_cattr(ap_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
			if (!secret) {
				ERROR("Could not retrieve secret key '%s' for BSS %s", secret_name, ap_ifname);
				continue;
			}
		}

		/* Add as BSS entry */
		fprintf(hostapd_conf, "\nbss=%s\n", ap_ifname);
		fprintf(hostapd_conf, "# SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	ly_set_free(ap_interfaces, NULL);
	fclose(hostapd_conf);

	/* Generate init script for the main interface */
	hostapd_finit = dagger_fopen_net_init(net, main_interface_name, NETDAG_INIT_POST, "hostapd.sh");
	if (!hostapd_finit)
		return SR_ERR_INTERNAL;

	fprintf(hostapd_finit, "# Generated by Infix confd\n");
	fprintf(hostapd_finit, "if [ -f '/etc/finit.d/enabled/hostapd@%s.conf' ];then\n", ifname);
	fprintf(hostapd_finit, "initctl -bfqn touch hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "else\n");
	fprintf(hostapd_finit, "initctl -bfqn enable hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "fi\n");
	fclose(hostapd_finit);

	return rc;
}

bool wifi_ap_must_delete(struct lyd_node *dif)
{

	struct lyd_node *cwifi;
	const char *radio_name;
	struct lyd_node *radio_dif;


	/* Get the wifi container from the current interface */
	cwifi = lydx_get_child(dif, "wifi");
	if (!cwifi)
		return false;

	/* Get the radio reference */
	radio_name = lydx_get_cattr(cwifi, "radio");
	if (!radio_name)
		return false;

	/* Look for the radio interface in dif to see if it's being deleted */
	radio_dif = lydx_get_xpathf(dif, "../interface[name='%s']", radio_name);
	if (radio_dif) {
		ERROR("%s must delete, radio change", lydx_get_cattr(dif, "name"));
		return true;
	}

	return false;
}

int wifi_gen_del(struct lyd_node *iface,  struct dagger *net)
{
	const char *ifname;
	FILE *fp;

	ifname = lydx_get_cattr(iface, "name");
	fp = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_PRE, "disable-wifi.sh");
	if (!fp) {
		ERROR("Failed to open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	/* Disable both station and AP services for this interface */
	disable_wifi_station(ifname, fp);
	disable_wifi_ap(ifname, fp);
	fclose(fp);
	return SR_ERR_OK;
}
