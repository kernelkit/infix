/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>
#include <string.h>

#include "interfaces.h"

#define WPA_SUPPLICANT_FINIT_CONF "/etc/finit.d/available/wpa_supplicant-%s.conf"
#define WPA_SUPPLICANT_CONF       "/etc/wpa_supplicant-%s.conf"
#define HOSTAPD_SUPPLICANT_CONF   "/etc/hostapd-%s.conf"

/* Comparison function for sorting AP interfaces by name (ascending) */
static int compare_ap_interfaces(const void *a, const void *b)
{
	struct lyd_node *node_a = *(struct lyd_node **)a;
	struct lyd_node *node_b = *(struct lyd_node **)b;
	const char *name_a = lydx_get_cattr(node_a, "name");
	const char *name_b = lydx_get_cattr(node_b, "name");
	return strcmp(name_a, name_b);
}

struct lyd_node *wifi_ap_get_radio(struct lyd_node *cif) {
	struct lyd_node *wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		const char *radio = lydx_get_cattr(wifi, "radio");
		if (radio) {
			struct lyd_node *radio_if = lydx_get_xpathf(cif, "../interface[name='%s']", radio);
			if (radio_if)
				return radio_if;
		}
	}
	return NULL;
}
static int wifi_gen_station_config(const char *ifname, const char *ssid, const char *country, const char *secret, const char* encryption, struct dagger *net, int counter)
{
	FILE *wpa_supplicant = NULL, *wpa = NULL;
	char *encryption_str;
	int rc = SR_ERR_OK;

	ERROR("%s", __func__);
	if (!secret && (ssid && encryption)) {
		/* Not an error, updated from two ways, interface cb and keystore cb. */
		return 0;
	}

	wpa = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "wpa_supplicant.sh");
	if (!wpa) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	fprintf(wpa, "# Generated by Infix confd\n");

	fprintf(wpa, "if [ -f '/etc/finit.d/enabled/wifi@%s.conf' ];then\n", ifname);
	fprintf(wpa, "initctl -bfqn touch wifi@%s\n", ifname);
	fprintf(wpa, "else\n");
	fprintf(wpa, "initctl -bfqn enable wifi@%s\n", ifname);
	fprintf(wpa, "fi\n");
	fclose(wpa);

	wpa_supplicant = fopenf("w", WPA_SUPPLICANT_CONF, ifname);
	if (!wpa_supplicant) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	if (!ssid || !secret) {
		fprintf(wpa_supplicant,
			"ctrl_interface=/run/wpa_supplicant\n"
			"autoscan=periodic:10\n"
			"ap_scan=1\n");
	} else {
		if (!strcmp(encryption, "disabled")) {
			asprintf(&encryption_str, "key_mgmt=NONE");
		} else {
			asprintf(&encryption_str, "key_mgmt=SAE WPA-PSK\npsk=\"%s\"", secret);
		}
		if (!counter) { /* First SSID */
			fprintf(wpa_supplicant,
				"country=%s\n"
				"ctrl_interface=/run/wpa_supplicant\n"
				"autoscan=periodic:10\n"
				"ap_scan=1\n\n", country);
		}
		fprintf(wpa_supplicant, "network={\n"
			"bgscan=\"simple: 30:-45:300\"\n"
			"ssid=\"%s\"\n"
			"%s\n"
			"}\n\n", ssid, encryption_str);
		free(encryption_str);
	}
	fclose(wpa_supplicant);

out:
	return rc;

}
static void disable_wifi_station(const char *ifname, FILE *fp)
{
	ERROR("%s", __func__);
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "iw dev %s disconnect\n", ifname);
	fprintf(fp, "initctl -bfqn disable wifi@%s\n", ifname);
	erasef(WPA_SUPPLICANT_CONF, ifname);
}

static void disable_wifi_ap(const char *ifname, FILE *fp)
{
	ERROR("%s", __func__);
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "initctl -bfqn disable hostapd@%s\n", ifname);
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);
}
int wifi_gen(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net) {
	struct lyd_node *cwifi, *dwifi = NULL, *cmode, *dmode = NULL;
	const char *ifname = lydx_get_cattr(cif, "name");
	FILE *fp;
	cwifi = lydx_get_child(cif, "wifi");
	ERROR("%s", __func__);
	if (!cwifi)
		return SR_ERR_OK;
        cmode = lydx_get_child(cwifi, "mode");

	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");
	if (dif) {
		dwifi = lydx_get_child(dif, "wifi");
		if (dwifi)
			dmode = lydx_get_child(dwifi, "mode");
	}
	if (!lydx_get_cattr(cif, "enabled")) {
		if (dwifi) {
			if (dmode && !strcmp(lyd_get_value(dmode), "accesspoint"))
				disable_wifi_ap(ifname, fp);
			else
				disable_wifi_station(ifname, fp);
		}
		goto out;
	}

	if (cmode && !strcmp(lyd_get_value(cmode), "accesspoint")) {
		if (dmode && strcmp(lyd_get_value(dmode), "accesspoint"))
			disable_wifi_station(ifname, fp);
		wifi_ap_gen(cif, net);

	} else {
		if (dmode && strcmp(lyd_get_value(dmode), "station"))
			disable_wifi_ap(ifname, fp);
		/* Client */
		wifi_station_gen(cif, net);
	}
out:
	fclose(fp);
	return SR_ERR_OK;
}
int wifi_station_gen(struct lyd_node *cif, struct dagger *net)
{
	const char *ssid_name, *secret_name, *secret = NULL, *ifname, *country;
	const char *encryption, *mode;
	struct lyd_node *wifi, *secret_node;
	bool enabled;
        int counter = 0;
	FILE *fp;
	ERROR("%s", __func__);
	ifname      = lydx_get_cattr(cif, "name");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");

	if (!fp) {
		ERROR("Could not open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	enabled     = lydx_get_bool(cif, "enabled");
	wifi        = lydx_get_child(cif, "wifi");

	if (!enabled || !wifi) {
	        disable_wifi_station(ifname, fp);
		goto out;
	}

	mode = lydx_get_cattr(wifi, "mode");
	if (mode && !strcmp(mode, "accesspoint")) {
		/* Interface is in access point mode - handle radio setup */
		disable_wifi_station(ifname, fp);
		fclose(fp);
		return wifi_ap_gen(cif, net);
	}

	/* Clean up any existing station configuration */
	erasef(WPA_SUPPLICANT_CONF, ifname);

	country = lydx_get_cattr(wifi, "country-code");
	if (!country)
		country = "00";

	if (!lydx_get_child(wifi, "ssid")) {
		/* Only the presence container is set - radio only, no station connection */
		wifi_gen_station_config(ifname, NULL, country, NULL, NULL, net, 0);
		goto out;
	}

	ssid_name   = lydx_get_cattr(wifi, "ssid");
	secret_name = lydx_get_cattr(wifi, "secret");
	encryption  = lydx_get_cattr(wifi, "encryption");
	if (secret_name) {
		secret_node = lydx_get_xpathf(cif, "../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
		secret      = lydx_get_cattr(secret_node, "cleartext-key");
	}
	wifi_gen_station_config(ifname, ssid_name, country, secret, encryption, net, counter);
	counter++;

out:
	fclose(fp);
	return SR_ERR_OK;
}

int wifi_ap_del_iface(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	FILE *iw;
	bool is_last_ap = false;

	ifname = lydx_get_cattr(dif, "name");
	ERROR("%s: %s", __func__, ifname);

	wifi = lydx_get_child(dif, "wifi");
	if (wifi) {
		radio = lydx_get_cattr(wifi, "radio");
		ERROR("Found radio: %s for interface %s", radio, ifname);
		if (radio) {
			struct lyd_node *iface, *sibling;
			struct lyd_node **matching;
			uint32_t match_count = 0, alloc_count = 8;

			/* Iterate through sibling interfaces, filter for
			 * non-created wifi-ap interfaces with matching radio.
			 */
			matching = calloc(alloc_count, sizeof(struct lyd_node *));
			if (!matching)
				goto skip_position_check;

			sibling = lyd_first_sibling(dif);
			LYX_LIST_FOR_EACH(sibling, iface, "interface") {
				struct lyd_node *iface_radio_node;
				const char *iface_radio;

				/* Skip created interfaces - only consider deleted/modified */
				if (lydx_get_op(iface) == LYDX_OP_CREATE)
					continue;

				/* Check wifi/radio to identify wifi-ap interfaces */
				iface_radio_node = lydx_get_descendant(lyd_child(iface), "wifi", "radio", NULL);
				if (!iface_radio_node)
					continue;

				iface_radio = lyd_get_value(iface_radio_node);
				if (!iface_radio || strcmp(iface_radio, radio))
					continue;

				if (match_count >= alloc_count) {
					alloc_count *= 2;
					matching = realloc(matching, alloc_count * sizeof(struct lyd_node *));
				}
				matching[match_count++] = iface;
			}

			ERROR("Found %u non-created interfaces matching radio %s", match_count, radio);
			if (match_count > 0) {
				/* Sort in normal order to find the last AP (renamed radio) */
				qsort(matching, match_count, sizeof(struct lyd_node *), compare_ap_interfaces);

				for (uint32_t i = 0; i < match_count; i++) {
					const char *ap_ifname = lydx_get_cattr(matching[i], "name");
					ERROR("  AP[%d]: %s", i, ap_ifname);
					if (!strcmp(ap_ifname, ifname)) {
						is_last_ap = (i == match_count - 1);
						ERROR("  MATCH! is_last_ap=%d", is_last_ap);
						break;
					}
				}
			}

			free(matching);
		}
	}
skip_position_check:

	iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_POST, "exit-iw.sh");

	if (is_last_ap) {
		/* Last AP (e.g., wifi0-ap2) is the renamed radio - restore original radio name and MAC */
		fprintf(iw, "# Last AP is renamed radio, restore original radio name and MAC\n");
		fprintf(iw, "logger -t confd -p daemon.info \"Restoring radio name from %s to %s\"\n", ifname, radio);
		fprintf(iw, "ip link set dev %s down\n", ifname);
		fprintf(iw, "ip link property del dev %s altname %s 2>/dev/null || true\n", ifname, radio);
		fprintf(iw, "ip link set dev %s name %s\n", ifname, radio);
		/* Restore original MAC address from permaddr */
		fprintf(iw, "permaddr=$(ip -d -j link show dev %s | jq -rM '.[].permaddr // empty')\n", radio);
		fprintf(iw, "if [ -n \"$permaddr\" ]; then\n");
		fprintf(iw, "  logger -t confd -p daemon.info \"Restoring original MAC $permaddr on %s\"\n", radio);
		fprintf(iw, "  ip link set dev %s address $permaddr\n", radio);
		fprintf(iw, "fi\n");
	} else {
		/* Not last AP - delete virtual interface */
		fprintf(iw, "# Virtual AP interface, delete it\n");
		fprintf(iw, "logger -t confd -p daemon.info \"Deleting virtual AP interface %s\"\n", ifname);
		fprintf(iw, "iw dev %s del\n", ifname);
	}

	fclose(iw);

	return 0;
}

int wifi_ap_add_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	struct ly_set *ap_interfaces = NULL;
	FILE *iw;
	int rc;

	ifname = lydx_get_cattr(cif, "name");

	wifi = lydx_get_child(cif, "wifi");
	if (!wifi) {
		ERROR("wifi-ap interface %s missing wifi configuration", ifname);
		return SR_ERR_INVAL_ARG;
	}

	radio = lydx_get_cattr(wifi, "radio");
	if (!radio) {
		ERROR("wifi-ap interface %s missing radio reference", ifname);
		return SR_ERR_INVAL_ARG;
	}

	dagger_add_dep(&confd.netdag, ifname, radio);

	/* Find all wifi-ap interfaces that reference the same radio */
	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/wifi/radio]", &ap_interfaces);
	if (rc != LY_SUCCESS || !ap_interfaces || ap_interfaces->count == 0) {
		ERROR("Failed to find wifi-ap interfaces for radio %s", radio);
		return SR_ERR_INTERNAL;
	}

	/* Sort interfaces by name to ensure consistent ordering */
	qsort(ap_interfaces->dnodes, ap_interfaces->count, sizeof(struct lyd_node *), compare_ap_interfaces);

	/* Find our position in the AP list */
	bool is_last_ap = false;
	uint32_t last_idx = ap_interfaces->count - 1;
	for (uint32_t i = 0; i < ap_interfaces->count; i++) {
		if (ap_interfaces->dnodes[i] == cif) {
			is_last_ap = (i == last_idx);
			/* If not first, add dependency to previous AP for sequential creation */
			if (i > 0) {
				const char *prev_ap_name = lydx_get_cattr(ap_interfaces->dnodes[i-1], "name");
				dagger_add_dep(&confd.netdag, ifname, prev_ap_name);
				ERROR("Adding dependency: %s depends on %s (AP sequence)", ifname, prev_ap_name);
			}
			break;
		}
	}
	ly_set_free(ap_interfaces, NULL);

	iw = dagger_fopen_net_init(net, ifname, NETDAG_INIT_PRE, "init-iw.sh");

	if (is_last_ap) {
		/* Last AP interface - rename radio to AP name and preserve radio name as altname */
		fprintf(iw, "# Last AP interface, rename radio to AP name\n");
		fprintf(iw, "logger -t confd -p daemon.info \"Renaming radio %s to AP interface %s\"\n", radio, ifname);
		fprintf(iw, "ip link set dev %s down\n", radio);
		fprintf(iw, "ip link set dev %s name %s\n", radio, ifname);
		fprintf(iw, "ip link property add dev %s altname %s\n", ifname, radio);
	} else {
		/* Not last AP - create virtual interface on the radio */
		fprintf(iw, "# Virtual AP interface, create on radio\n");
		fprintf(iw, "logger -t confd -p daemon.info \"Creating virtual AP interface %s on %s\"\n", ifname, radio);
		fprintf(iw, "iw dev %s interface add %s type __ap\n", radio, ifname);
	}

	fclose(iw);

	return 0;
}

int wifi_is_accesspoint(struct lyd_node *cif) {
	struct lyd_node *wifi;
	const char *mode;
	ERROR("%s", __func__);
	wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		mode = lydx_get_cattr(wifi, "mode");
		ERROR("Accesspoint?: %d", !!strcmp(mode, "accesspoint"));
		if (mode)
			return !!strcmp(mode, "accesspoint");
	}
	ERROR("NOT ACCESSPOINT");
	return 0;
}
int wifi_ap_gen(struct lyd_node *cif, struct dagger *net)
{
	struct lyd_node *wifi, *ap_interface;
	struct ly_set *ap_interfaces = NULL;
	FILE *hostapd_conf, *hostapd_finit;
	const char *country, *band, *channel, *ifname;
	const char *main_interface_name;
	bool freq_24GHz;
	int rc = SR_ERR_OK;

	ERROR("%s", __func__);
	ERROR("GENERATE AP");
	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	country = lydx_get_cattr(wifi, "country-code");
	band = lydx_get_cattr(wifi, "band");
	channel = lydx_get_cattr(wifi, "channel");
	freq_24GHz = !strcmp(band, "2.4GHz");

	if (!channel || !strcmp(channel, "auto"))
		channel = freq_24GHz ? "6" : "149";

	ERROR("Searching radio");
	/* Find all wifi-ap interfaces that reference this radio */
	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/name]", &ap_interfaces);
	if (rc != LY_SUCCESS || !ap_interfaces || ap_interfaces->count == 0) {
		ERROR("No wifi-ap interfaces reference radio %s", ifname);
		return SR_ERR_OK;
	}

	/* Sort interfaces by name to ensure consistent ordering */
	qsort(ap_interfaces->dnodes, ap_interfaces->count, sizeof(struct lyd_node *), compare_ap_interfaces);

	/* The last AP interface becomes the main interface (radio gets renamed to this) */
	ap_interface = ap_interfaces->dnodes[ap_interfaces->count - 1];
	main_interface_name = lydx_get_cattr(ap_interface, "name");

	ERROR("Generating hostapd config for radio %s, main interface %s with %d total APs",
		  ifname, main_interface_name, ap_interfaces->count);

	/* Clean up any existing AP configuration */
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);

	hostapd_conf = fopenf("w", HOSTAPD_SUPPLICANT_CONF, ifname);
	if (!hostapd_conf) {
		ly_set_free(ap_interfaces, NULL);
		return SR_ERR_INTERNAL;
	}

	fprintf(hostapd_conf, "# Generated by Infix confd for radio %s (main interface %s)\n",
			ifname, main_interface_name);

	/* Basic hostapd configuration using the main AP interface name */
	fprintf(hostapd_conf,
		"interface=%s\n"
		"driver=nl80211\n"
		"hw_mode=%c\n"
		"wmm_enabled=1\n"
		"channel=%s\n"
		"logger_syslog=-1\n"
		"logger_syslog_level=0\n"
		"logger_stdout=0\n"
		"ctrl_interface=/var/run/hostapd\n"
		"ctrl_interface_group=0\n\n",
		main_interface_name, freq_24GHz ? 'g' : 'a', channel);

	if (strcmp(country, "00"))
		fprintf(hostapd_conf, "country_code=%s\n", country);

	if (freq_24GHz)
		fprintf(hostapd_conf, "ieee80211n=1\n");
	else
		fprintf(hostapd_conf, "ieee80211ac=1\n");

	/* Configure last AP interface as main SSID (it's the renamed radio) */
	struct lyd_node *main_wifi = lydx_get_child(ap_interface, "wifi");
	if (main_wifi) {
		const char *ssid = lydx_get_cattr(main_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(main_wifi, "secret");
		const char *encryption = lydx_get_cattr(main_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
		}

		fprintf(hostapd_conf, "\n# Main SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	/* Add other AP interfaces as BSS entries (all except the last one) */
	for (uint32_t i = 0; i < ap_interfaces->count - 1; i++) {
		ap_interface = ap_interfaces->dnodes[i];
		const char *ap_ifname = lydx_get_cattr(ap_interface, "name");
		struct lyd_node *ap_wifi = lydx_get_child(ap_interface, "wifi");

		if (!ap_wifi) continue;

		const char *ssid = lydx_get_cattr(ap_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(ap_wifi, "secret");
		const char *encryption = lydx_get_cattr(ap_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
			if (!secret) {
				ERROR("Could not retrieve secret key '%s' for BSS %s", secret_name, ap_ifname);
				continue;
			}
		}

		/* Add as BSS entry */
		fprintf(hostapd_conf, "\nbss=%s\n", ap_ifname);
		fprintf(hostapd_conf, "# SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	ly_set_free(ap_interfaces, NULL);
	fclose(hostapd_conf);

	/* Generate init script for the main interface */
	hostapd_finit = dagger_fopen_net_init(net, main_interface_name, NETDAG_INIT_POST, "hostapd.sh");
	if (!hostapd_finit)
		return SR_ERR_INTERNAL;

	fprintf(hostapd_finit, "# Generated by Infix confd\n");
	fprintf(hostapd_finit, "if [ -f '/etc/finit.d/enabled/hostapd@%s.conf' ];then\n", ifname);
	fprintf(hostapd_finit, "initctl -bfqn touch hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "else\n");
	fprintf(hostapd_finit, "initctl -bfqn enable hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "fi\n");
	fclose(hostapd_finit);

	return rc;
}

bool wifi_ap_must_delete(struct lyd_node *dif)
{

	struct lyd_node *cwifi;
	const char *radio_name;
	struct lyd_node *radio_dif;
	ERROR("%s", __func__);

	/* Get the wifi container from the current interface */
	cwifi = lydx_get_child(dif, "wifi");
	if (!cwifi)
		return false;

	/* Get the radio reference */
	radio_name = lydx_get_cattr(cwifi, "radio");
	if (!radio_name)
		return false;

	/* Look for the radio interface in dif to see if it's being deleted */
	radio_dif = lydx_get_xpathf(dif, "../interface[name='%s']", radio_name);
	if (radio_dif) {
		ERROR("%s must delete, radio change", lydx_get_cattr(dif, "name"));
		return true;
	}

	return false;
}

int wifi_gen_del(struct lyd_node *iface,  struct dagger *net)
{
	const char *ifname;
	FILE *fp;
	ERROR("%s", __func__);
	ifname = lydx_get_cattr(iface, "name");
	fp = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_PRE, "disable-wifi.sh");
	if (!fp) {
		ERROR("Failed to open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	/* Disable both station and AP services for this interface */
	disable_wifi_station(ifname, fp);
	disable_wifi_ap(ifname, fp);
	fclose(fp);
	return SR_ERR_OK;
}
