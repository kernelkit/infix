/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>

#include "interfaces.h"

/*
 * WiFi Interface Management
 *
 * This file handles only virtual WiFi interface creation/deletion.
 * WiFi daemon configuration (hostapd/wpa_supplicant) is handled by
 * hardware.c when the WiFi radio (phy) is configured.
 */

/*
 * Determine WiFi mode from YANG configuration
 */
typedef enum wifi_mode_t {
	wifi_station,
	wifi_ap,
	wifi_unknown
} wifi_mode_t;
static wifi_mode_t wifi_get_mode(struct lyd_node *wifi)
{
	if (lydx_get_child(wifi, "access-point"))
		return wifi_ap;
	else
		return wifi_station; /* Need to return station even if "station" also is false, since that is the default scanning mode */
}

int wifi_mode_changed(struct lyd_node *wifi)
{
	struct lyd_node *station, *ap;
	enum lydx_op station_op, ap_op;

	if (!wifi)
		return 0;
	station = lydx_get_child(wifi, "station");
	ap = lydx_get_child(wifi, "access-point");
	if (station)
		station_op = lydx_get_op(station);
	if (ap)
		ap_op = lydx_get_op(ap);

	return ((station && station_op == LYDX_OP_DELETE) || (ap && ap_op == LYDX_OP_DELETE));
}
/*
 * Add WiFi virtual interface using iw
 */
int wifi_add_iface(struct lyd_node *cif, struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	wifi_mode_t mode;
	FILE *iw;
	int rc = SR_ERR_OK;

	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	if (!wifi) {
		ERROR("WiFi interface %s: no wifi container", ifname);
		return SR_ERR_INVAL_ARG;
	}

	radio = lydx_get_cattr(wifi, "radio");
	if (!radio) {
		ERROR("WiFi interface %s: missing radio reference", ifname);
		return SR_ERR_INVAL_ARG;
	}

	iw = dagger_fopen_net_init(net, ifname, NETDAG_INIT_PRE, "wifi-iface.sh");
	if (!iw) {
		ERROR("Failed to open dagger file for WiFi interface creation");
		return SR_ERR_INTERNAL;
	}

	mode = wifi_get_mode(wifi);

	fprintf(iw, "# Generated by Infix confd - WiFi Interface Creation\n");
	fprintf(iw, "# Create %s interface %s on radio %s\n",
		mode == wifi_station ? "station" : "access point", ifname, radio);

	switch(mode) {
	case wifi_station:
		fprintf(iw, "iw phy %s interface add %s type managed\n", radio, ifname);
		break;
	case wifi_ap:
		fprintf(iw, "iw phy %s interface add %s type __ap\n", radio, ifname);
		break;
	default:
		ERROR("WiFi mode %d unknown", mode);
		rc = SR_ERR_INVAL_ARG;
		goto out;
	}
out:
	fclose(iw);
	return rc;
}

/*
 * Delete WiFi virtual interface using iw
 */
int wifi_del_iface(struct lyd_node *dif, struct dagger *net)
{
	const char *ifname;
	FILE *iw;

	ifname = lydx_get_cattr(dif, "name");

	iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_POST, "wifi-iface.sh");
	if (!iw) {
		ERROR("Failed to open dagger file for WiFi interface deletion");
		return SR_ERR_INTERNAL;
	}

	fprintf(iw, "# Generated by Infix confd - WiFi Interface Deletion\n");
	fprintf(iw, "ip link set %s down\n", ifname); /* Required to change modes. */
	fprintf(iw, "iw dev %s disconnect\n", ifname);
	fprintf(iw, "iw dev %s del\n", ifname);
	fclose(iw);

	return SR_ERR_OK;
}
