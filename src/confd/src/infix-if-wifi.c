/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>

#include "ietf-interfaces.h"

#define WPA_SUPPLICANT_FINIT_CONF "/etc/finit.d/available/wpa_supplicant-%s.conf"
#define WPA_SUPPLICANT_CONF       "/etc/wpa_supplicant-%s.conf"
#define HOSTAPD_SUPPLICANT_CONF   "/etc/hostapd-%s.conf"

static int wifi_gen_station_config(const char *ifname, const char *ssid, const char *country, const char *secret, const char* encryption, struct dagger *net, int counter)
{
	FILE *wpa_supplicant = NULL, *wpa = NULL;
	char *encryption_str;
	int rc = SR_ERR_OK;

	if (!secret && (ssid && encryption)) {
		/* Not an error, updated from two ways, interface cb and keystore cb. */
		return 0;
	}

	wpa = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "wpa_supplicant.sh");
	if (!wpa) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	fprintf(wpa, "# Generated by Infix confd\n");

	fprintf(wpa, "if [ -f '/etc/finit.d/enabled/wifi@%s.conf' ];then\n", ifname);
	fprintf(wpa, "initctl -bfqn touch wifi@%s\n", ifname);
	fprintf(wpa, "else\n");
	fprintf(wpa, "initctl -bfqn enable wifi@%s\n", ifname);
	fprintf(wpa, "fi\n");
	fclose(wpa);

	wpa_supplicant = fopenf("w", WPA_SUPPLICANT_CONF, ifname);
	if (!wpa_supplicant) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	if (!ssid || !secret) {
		fprintf(wpa_supplicant,
			"ctrl_interface=/run/wpa_supplicant\n"
			"autoscan=periodic:10\n"
			"ap_scan=1\n");
	} else {
		if (!encryption) {
			asprintf(&encryption_str, "key_mgmt=NONE");
		} else {
			asprintf(&encryption_str, "key_mgmt=SAE WPA-PSK\npsk=\"%s\"", secret);
		}
		if (!counter) { /* First SSID */
			fprintf(wpa_supplicant,
				"country=%s\n"
				"ctrl_interface=/run/wpa_supplicant\n"
				"autoscan=periodic:10\n"
				"ap_scan=1\n\n", country);
		}
		fprintf(wpa_supplicant, "network={\n"
			"bgscan=\"simple: 30:-45:300\"\n"
			"ssid=\"%s\"\n"
			"%s\n"
			"}\n\n", ssid, encryption_str);
		free(encryption_str);
	}
	fclose(wpa_supplicant);

out:
	return rc;

}
static void disable_wifi_station(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "iw dev %s disconnect\n", ifname);
	fprintf(fp, "initctl -bfqn disable wifi@%s\n", ifname);
	erasef(WPA_SUPPLICANT_CONF, ifname);
}

static void disable_wifi_ap(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "initctl -bfqn disable hostapd@%s\n", ifname);
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);
}
int wifi_gen(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net) {
	struct lyd_node *cwifi, *dwifi = NULL, *cmode, *dmode = NULL;
	const char *ifname = lydx_get_cattr(cif, "name");
	FILE *fp;
	cwifi = lydx_get_child(cif, "wifi");
	if (!cwifi)
		return SR_ERR_OK;
        cmode = lydx_get_child(cwifi, "mode");

	ERROR("NOW GENERATE WIFI");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");
	if (dif) {
		dwifi = lydx_get_child(dif, "wifi");
		if (dwifi)
			dmode = lydx_get_child(dwifi, "mode");
	}
	if (!lydx_get_cattr(cif, "enabled")) {
		ERROR("INTERFACE DISSABLED");
		if (dwifi) {
			if (dmode && !strcmp(lyd_get_value(dmode), "accesspoint"))
				disable_wifi_ap(ifname, fp);
			else
				disable_wifi_station(ifname, fp);
		}
		goto out;
	}

	if (cmode && !strcmp(lyd_get_value(cmode), "accesspoint")) {
		ERROR("Should now configure AP");
		if (dmode && strcmp(lyd_get_value(dmode), "accesspoint"))
			disable_wifi_station(ifname, fp);
		wifi_ap_gen(cif, net);

	} else {
		ERROR("Should now configure station");
		if (dmode && strcmp(lyd_get_value(dmode), "station"))
			disable_wifi_ap(ifname, fp);
		/* Client */
		wifi_station_gen(cif, net);
	}
out:
	fclose(fp);
	return SR_ERR_OK;
}
int wifi_station_gen(struct lyd_node *cif, struct dagger *net)
{
	const char *ssid_name, *secret_name, *secret = NULL, *ifname, *country;
	const char *encryption, *mode;
	struct lyd_node *wifi, *secret_node;
	bool enabled;
        int counter = 0;
	FILE *fp;

	ERROR("GENERATE STATION");
	ifname      = lydx_get_cattr(cif, "name");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");

	if (!fp) {
		ERROR("Could not open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	enabled     = lydx_get_bool(cif, "enabled");
	wifi        = lydx_get_child(cif, "wifi");

	if (!enabled || !wifi) {
	        disable_wifi_station(ifname, fp);
		goto out;
	}

	mode = lydx_get_cattr(wifi, "mode");
	if (mode && !strcmp(mode, "accesspoint")) {
		/* Interface is in access point mode - handle radio setup */
		disable_wifi_station(ifname, fp);
		fclose(fp);
		return wifi_ap_gen(cif, net);
	}

	/* Clean up any existing station configuration */
	erasef(WPA_SUPPLICANT_CONF, ifname);

	country = lydx_get_cattr(wifi, "country-code");
	if (!country)
		country = "00";

	if (!lydx_get_child(wifi, "ssid")) {
		/* Only the presence container is set - radio only, no station connection */
		wifi_gen_station_config(ifname, NULL, country, NULL, NULL, net, 0);
		goto out;
	}

	ssid_name   = lydx_get_cattr(wifi, "ssid");
	secret_name = lydx_get_cattr(wifi, "secret");
	encryption  = lydx_get_cattr(wifi, "encryption");
	if (encryption && secret_name) {
		secret_node = lydx_get_xpathf(cif, "../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
		secret      = lydx_get_cattr(secret_node, "cleartext-key");
	}
	wifi_gen_station_config(ifname, ssid_name, country, secret, encryption, net, counter);
	counter++;

out:
	fclose(fp);
	return SR_ERR_OK;
}

int wifi_ap_del_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname/*, *radio */;
	FILE *iw;

	ifname = lydx_get_cattr(cif, "name");
	iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT, "exit-iw.sh");
	fprintf(iw, "iw dev %s del\n", ifname);
	fclose(iw);

	return 0;
}

int wifi_ap_add_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	FILE *iw;

	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");
	if (!wifi) {
		ERROR("wifi-ap interface %s missing wifi configuration", ifname);
		return SR_ERR_INVAL_ARG;
	}

	radio = lydx_get_cattr(wifi, "radio");
	if (!radio) {
		ERROR("wifi-ap interface %s missing radio reference", ifname);
		return SR_ERR_INVAL_ARG;
	}

	dagger_add_dep(&confd.netdag, ifname, radio);
	iw = dagger_fopen_net_init(net, ifname, NETDAG_INIT_PRE, "init-iw.sh");
	fprintf(iw, "iw dev %s interface add %s type __ap\n", radio, ifname);
	fclose(iw);

	return 0;
}


int wifi_ap_gen(struct lyd_node *cif, struct dagger *net)
{
	struct lyd_node *wifi, *ap_interface;
	struct ly_set *ap_interfaces = NULL;
	FILE *hostapd_conf, *hostapd_finit;
	const char *country, *band, *channel, *ifname;
	int rc = SR_ERR_OK;

	ERROR("GENERATE AP");
	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	/* Clean up any existing AP configuration */
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);
	bool freq_24GHz;
	hostapd_conf = fopenf("w", HOSTAPD_SUPPLICANT_CONF, ifname);
	if (!hostapd_conf) {
		return SR_ERR_INTERNAL;
	}

	fprintf(hostapd_conf, "# Generated by Infix confd\n");

	country = lydx_get_cattr(wifi, "country-code");
	if (!country)
		country = "00";

	band = lydx_get_cattr(wifi, "band");
	channel = lydx_get_cattr(wifi, "channel");
	freq_24GHz = !strcmp(band, "2.4GHz");

	if (!channel || !strcmp(channel, "auto"))
		channel = freq_24GHz ? "6" : "149";

	fprintf(hostapd_conf,
		"interface=%s\n"
		"driver=nl80211\n"
		"hw_mode=%c\n"
		"country_code=%s\n"
		"wmm_enabled=1\n"      /* QoS */
		"channel=%s\n"
		"logger_syslog=-1\n"
		"logger_syslog_level=0\n"
		"logger_stdout=0\n"
		"ctrl_interface=/var/run/hostapd\n"
		"ctrl_interface_group=0\n\n",
		ifname, freq_24GHz ? 'g' : 'a', country, channel);

	if (freq_24GHz)
		fprintf(hostapd_conf, "ieee80211n=1\n");
	else
		fprintf(hostapd_conf, "ieee80211ac=1\n");


	/* Find all wifi-ap interfaces that reference this radio */
	ERROR("Searching for wifi-ap interfaces referencing radio: %s", ifname);

	/* First, let's see what interfaces exist at all */
	rc = lyd_find_xpath(cif, "../interface", &ap_interfaces);
	if (rc == LY_SUCCESS && ap_interfaces && ap_interfaces->count > 0) {
		ERROR("Found %d total interfaces", ap_interfaces->count);
		for (uint32_t i = 0; i < ap_interfaces->count; i++) {
			struct lyd_node *iface = ap_interfaces->dnodes[i];
			const char *iface_name = lydx_get_cattr(iface, "name");
			const char *iface_type = lydx_get_cattr(iface, "type");
			ERROR("  Interface: %s, type: %s", iface_name ? iface_name : "NULL", iface_type ? iface_type : "NULL");
		}
		ly_set_free(ap_interfaces, NULL);
	}

	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap')]", &ap_interfaces);
	if (rc == LY_SUCCESS && ap_interfaces && ap_interfaces->count > 0) {
		ERROR("Found %d wifi-ap interfaces", ap_interfaces->count);
		for (uint32_t i = 0; i < ap_interfaces->count; i++) {
			struct lyd_node *ap_if = ap_interfaces->dnodes[i];
			const char *ap_name = lydx_get_cattr(ap_if, "name");
			struct lyd_node *ap_wifi = lydx_get_child(ap_if, "wifi");
			const char *ap_radio = ap_wifi ? lydx_get_cattr(ap_wifi, "radio") : "NULL";
			ERROR("  AP interface: %s, radio reference: %s", ap_name ? ap_name : "NULL", ap_radio);
		}
		ly_set_free(ap_interfaces, NULL);
	}

	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/name]", &ap_interfaces);
	if (rc != LY_SUCCESS || !ap_interfaces || ap_interfaces->count == 0) {
		/* No AP interfaces found referencing this radio */
		ERROR("No wifi-ap reference this radio device (%s)", ifname);
		fclose(hostapd_conf);
		return SR_ERR_OK;
	}

	/* Iterate through all AP interfaces that reference this radio */
	for (uint32_t i = 0; i < ap_interfaces->count; i++) {
		ap_interface = ap_interfaces->dnodes[i];

		const char *ap_ifname = lydx_get_cattr(ap_interface, "name");
		ERROR("Adding %s", ap_ifname);
		struct lyd_node *ap_wifi = lydx_get_child(ap_interface, "wifi");

		if (!ap_wifi) continue;

		/* Get AP configuration */
		const char *ssid = lydx_get_cattr(ap_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(ap_wifi, "secret");
		const char *encryption = lydx_get_cattr(ap_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
			if (!secret) {
				ERROR("Could not retrieve secret key '%s'", secret_name);
				continue; /* Skip this AP but continue with others */
			}
		}

		/* SSID configuration */
		fprintf(hostapd_conf, "bss=%s\n", ap_ifname);
		fprintf(hostapd_conf, "# SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);
		if (encryption) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n",hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n",hostapd_conf); /* This to allow WPA2 stations */
			fputs("wpa=2\n",hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}
	ly_set_free(ap_interfaces, NULL);

	hostapd_finit = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "hostapd.sh");
	if (!hostapd_finit)
	       return SR_ERR_INTERNAL;


	fprintf(hostapd_finit, "# Generated by Infix confd\n");
	fprintf(hostapd_finit, "if [ -f '/etc/finit.d/enabled/hostapd@%s.conf' ];then\n", ifname);
	fprintf(hostapd_finit, "initctl -bfqn touch hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "else\n");
	fprintf(hostapd_finit, "initctl -bfqn enable hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "fi\n");
	fclose(hostapd_finit);

	return rc;
}

bool wifi_ap_must_delete(struct lyd_node *dif)
{
	struct lyd_node *cwifi;
	const char *radio_name;
	struct lyd_node *radio_dif;


	/* Get the wifi container from the current interface */
	cwifi = lydx_get_child(dif, "wifi");
	if (!cwifi)
		return false;

	/* Get the radio reference */
	radio_name = lydx_get_cattr(cwifi, "radio");
	if (!radio_name)
		return false;

	/* Look for the radio interface in dif to see if it's being deleted */
	radio_dif = lydx_get_xpathf(dif, "../interface[name='%s']", radio_name);
	if (radio_dif) {
		ERROR("%s must delete, radio change", lydx_get_cattr(dif, "name"));
		return true;
	}

	return false;
}

int wifi_gen_del(struct lyd_node *iface,  struct dagger *net)
{
	const char *ifname;
	FILE *fp;

	ifname = lydx_get_cattr(iface, "name");
	fp = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_PRE, "disable-wifi.sh");
	if (!fp) {
		ERROR("Failed to open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	/* Disable both station and AP services for this interface */
	disable_wifi_station(ifname, fp);
	disable_wifi_ap(ifname, fp);
	fclose(fp);
	return SR_ERR_OK;
}
