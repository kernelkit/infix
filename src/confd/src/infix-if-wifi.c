/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>

#include "ietf-interfaces.h"

#define WPA_SUPPLICANT_FINIT_CONF "/etc/finit.d/available/wpa_supplicant-%s.conf"
#define WPA_SUPPLICANT_CONF       "/etc/wpa_supplicant-%s.conf"
#define HOSTAPD_SUPPLICANT_CONF   "/etc/hostapd-%s.conf"

struct lyd_node *wifi_ap_get_radio(struct lyd_node *cif) {
	struct lyd_node *wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		const char *radio = lydx_get_cattr(wifi, "radio");
		if (radio) {
			struct lyd_node *radio_if = lydx_get_xpathf(cif, "../interface[name='%s']", radio);
			if (radio_if)
				return radio_if;
		}
	}
	return NULL;
}
static int wifi_gen_station_config(const char *ifname, const char *ssid, const char *country, const char *secret, const char* encryption, struct dagger *net, int counter)
{
	FILE *wpa_supplicant = NULL, *wpa = NULL;
	char *encryption_str;
	int rc = SR_ERR_OK;

	if (!secret && (ssid && encryption)) {
		/* Not an error, updated from two ways, interface cb and keystore cb. */
		return 0;
	}

	wpa = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "wpa_supplicant.sh");
	if (!wpa) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	fprintf(wpa, "# Generated by Infix confd\n");

	fprintf(wpa, "if [ -f '/etc/finit.d/enabled/wifi@%s.conf' ];then\n", ifname);
	fprintf(wpa, "initctl -bfqn touch wifi@%s\n", ifname);
	fprintf(wpa, "else\n");
	fprintf(wpa, "initctl -bfqn enable wifi@%s\n", ifname);
	fprintf(wpa, "fi\n");
	fclose(wpa);

	wpa_supplicant = fopenf("w", WPA_SUPPLICANT_CONF, ifname);
	if (!wpa_supplicant) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	if (!ssid || !secret) {
		fprintf(wpa_supplicant,
			"ctrl_interface=/run/wpa_supplicant\n"
			"autoscan=periodic:10\n"
			"ap_scan=1\n");
	} else {
		if (!strcmp(encryption, "disabled")) {
			asprintf(&encryption_str, "key_mgmt=NONE");
		} else {
			asprintf(&encryption_str, "key_mgmt=SAE WPA-PSK\npsk=\"%s\"", secret);
		}
		if (!counter) { /* First SSID */
			fprintf(wpa_supplicant,
				"country=%s\n"
				"ctrl_interface=/run/wpa_supplicant\n"
				"autoscan=periodic:10\n"
				"ap_scan=1\n\n", country);
		}
		fprintf(wpa_supplicant, "network={\n"
			"bgscan=\"simple: 30:-45:300\"\n"
			"ssid=\"%s\"\n"
			"%s\n"
			"}\n\n", ssid, encryption_str);
		free(encryption_str);
	}
	fclose(wpa_supplicant);

out:
	return rc;

}
static void disable_wifi_station(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "iw dev %s disconnect\n", ifname);
	fprintf(fp, "initctl -bfqn disable wifi@%s\n", ifname);
	erasef(WPA_SUPPLICANT_CONF, ifname);
}

static void disable_wifi_ap(const char *ifname, FILE *fp)
{
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "initctl -bfqn disable hostapd@%s\n", ifname);
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);
}
int wifi_gen(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net) {
	struct lyd_node *cwifi, *dwifi = NULL, *cmode, *dmode = NULL;
	const char *ifname = lydx_get_cattr(cif, "name");
	FILE *fp;
	cwifi = lydx_get_child(cif, "wifi");
	if (!cwifi)
		return SR_ERR_OK;
        cmode = lydx_get_child(cwifi, "mode");

	ERROR("NOW GENERATE WIFI");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");
	if (dif) {
		dwifi = lydx_get_child(dif, "wifi");
		if (dwifi)
			dmode = lydx_get_child(dwifi, "mode");
	}
	if (!lydx_get_cattr(cif, "enabled")) {
		ERROR("INTERFACE DISSABLED");
		if (dwifi) {
			if (dmode && !strcmp(lyd_get_value(dmode), "accesspoint"))
				disable_wifi_ap(ifname, fp);
			else
				disable_wifi_station(ifname, fp);
		}
		goto out;
	}

	if (cmode && !strcmp(lyd_get_value(cmode), "accesspoint")) {
		ERROR("Should now configure AP");
		if (dmode && strcmp(lyd_get_value(dmode), "accesspoint"))
			disable_wifi_station(ifname, fp);
		wifi_ap_gen(cif, net);

	} else {
		ERROR("Should now configure station");
		if (dmode && strcmp(lyd_get_value(dmode), "station"))
			disable_wifi_ap(ifname, fp);
		/* Client */
		wifi_station_gen(cif, net);
	}
out:
	fclose(fp);
	return SR_ERR_OK;
}
int wifi_station_gen(struct lyd_node *cif, struct dagger *net)
{
	const char *ssid_name, *secret_name, *secret = NULL, *ifname, *country;
	const char *encryption, *mode;
	struct lyd_node *wifi, *secret_node;
	bool enabled;
        int counter = 0;
	FILE *fp;

	ERROR("GENERATE STATION");
	ifname      = lydx_get_cattr(cif, "name");
	fp = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "disable-wifi.sh");

	if (!fp) {
		ERROR("Could not open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	enabled     = lydx_get_bool(cif, "enabled");
	wifi        = lydx_get_child(cif, "wifi");

	if (!enabled || !wifi) {
	        disable_wifi_station(ifname, fp);
		goto out;
	}

	mode = lydx_get_cattr(wifi, "mode");
	if (mode && !strcmp(mode, "accesspoint")) {
		/* Interface is in access point mode - handle radio setup */
		disable_wifi_station(ifname, fp);
		fclose(fp);
		return wifi_ap_gen(cif, net);
	}

	/* Clean up any existing station configuration */
	erasef(WPA_SUPPLICANT_CONF, ifname);

	country = lydx_get_cattr(wifi, "country-code");
	if (!country)
		country = "00";

	if (!lydx_get_child(wifi, "ssid")) {
		/* Only the presence container is set - radio only, no station connection */
		wifi_gen_station_config(ifname, NULL, country, NULL, NULL, net, 0);
		goto out;
	}

	ssid_name   = lydx_get_cattr(wifi, "ssid");
	secret_name = lydx_get_cattr(wifi, "secret");
	encryption  = lydx_get_cattr(wifi, "encryption");
	if (secret_name) {
		secret_node = lydx_get_xpathf(cif, "../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
		secret      = lydx_get_cattr(secret_node, "cleartext-key");
	}
	wifi_gen_station_config(ifname, ssid_name, country, secret, encryption, net, counter);
	counter++;

out:
	fclose(fp);
	return SR_ERR_OK;
}

int wifi_ap_del_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	struct ly_set *remaining_aps = NULL;
	bool is_last_ap = false;
	FILE *iw;
	int rc;

	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	if (wifi) {
		radio = lydx_get_cattr(wifi, "radio");

		/* Check if this is the last AP interface for this radio */
		if (radio) {
			rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/wifi/radio and name != current()/name]", &remaining_aps);
			if (rc != LY_SUCCESS || !remaining_aps || remaining_aps->count == 0) {
				is_last_ap = true;
				ERROR("Interface %s is the last AP for radio %s - will restore radio name", ifname, radio);
			} else {
				ERROR("Interface %s removal leaves %d other APs for radio %s", ifname, remaining_aps->count, radio);
			}

			if (remaining_aps)
				ly_set_free(remaining_aps, NULL);
		}
	}

	iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT, "exit-iw.sh");

	if (is_last_ap && radio) {
		/* Last AP interface: restore original radio name */
		fprintf(iw, "# Restore radio name from %s back to %s\n", ifname, radio);
		fprintf(iw, "ip link set dev %s name %s\n", ifname, radio);
		fprintf(iw, "ip link property del dev %s altname %s\n", radio, radio);
	} else {
		/* Virtual AP interface: delete it */
		fprintf(iw, "# Delete virtual AP interface %s\n", ifname);
		fprintf(iw, "iw dev %s del\n", ifname);
	}

	fclose(iw);

	return 0;
}


int wifi_ap_add_iface(struct lyd_node *cif,struct dagger *net)
{
	const char *ifname, *radio;
	struct lyd_node *wifi;
	struct ly_set *existing_aps = NULL;
	bool is_first_ap = false;
	FILE *iw;
	int rc;

	ifname = lydx_get_cattr(cif, "name");

	wifi = lydx_get_child(cif, "wifi");
	if (!wifi) {
		ERROR("wifi-ap interface %s missing wifi configuration", ifname);
		return SR_ERR_INVAL_ARG;
	}

	radio = lydx_get_cattr(wifi, "radio");
	if (!radio) {
		ERROR("wifi-ap interface %s missing radio reference", ifname);
		return SR_ERR_INVAL_ARG;
	}

	/* Check if this is the first AP interface for this radio by finding all APs for this radio */
	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/wifi/radio]", &existing_aps);
	if (rc == LY_SUCCESS && existing_aps && existing_aps->count > 0) {
		/* Check if current interface is the first one in the list */
		const char *first_ap_name = lydx_get_cattr(existing_aps->dnodes[0], "name");
		if (!strcmp(ifname, first_ap_name)) {
			is_first_ap = true;
			ERROR("Interface %s is the first AP for radio %s - will rename radio", ifname, radio);
		} else {
			ERROR("Interface %s is additional AP for radio %s - will create virtual interface", ifname, radio);
		}
	} else {
		/* Fallback: if we can't determine, assume first */
		is_first_ap = true;
		ERROR("Interface %s assumed to be first AP for radio %s", ifname, radio);
	}

	if (existing_aps)
		ly_set_free(existing_aps, NULL);

	dagger_add_dep(&confd.netdag, ifname, radio);
	iw = dagger_fopen_net_init(net, ifname, NETDAG_INIT_PRE, "init-iw.sh");

	if (is_first_ap) {
		/* First AP interface: rename radio interface to AP name */
		fprintf(iw, "# Rename radio %s to first AP interface %s\n", radio, ifname);
		fprintf(iw, "ip link set dev %s name %s\n", radio, ifname);
		fprintf(iw, "ip link property add dev %s altname %s\n", ifname, radio);
	} else {
		/* Additional AP interfaces: create virtual interface as before */
		fprintf(iw, "# Create virtual AP interface %s on radio %s\n", ifname, radio);
		fprintf(iw, "iw dev %s interface add %s type __ap\n", radio, ifname);
	}

	fclose(iw);

	return 0;
}

int wifi_is_accesspoint(struct lyd_node *cif) {
	struct lyd_node *wifi;
	const char *mode;

	wifi = lydx_get_child(cif, "wifi");
	if (wifi) {
		mode = lydx_get_cattr(wifi, "mode");
		ERROR("Accesspoint?: %d", !!strcmp(mode, "accesspoint"));
		if (mode)
			return !!strcmp(mode, "accesspoint");
	}
	ERROR("NOT ACCESSPOINT");
	return 0;
}
int wifi_ap_gen(struct lyd_node *cif, struct dagger *net)
{
	struct lyd_node *wifi, *ap_interface;
	struct ly_set *ap_interfaces = NULL;
	FILE *hostapd_conf, *hostapd_finit;
	const char *country, *band, *channel, *ifname;
	const char *main_interface_name;
	bool freq_24GHz;
	int rc = SR_ERR_OK;

	ERROR("GENERATE AP");
	ifname = lydx_get_cattr(cif, "name");
	wifi = lydx_get_child(cif, "wifi");

	country = lydx_get_cattr(wifi, "country-code");
	band = lydx_get_cattr(wifi, "band");
	channel = lydx_get_cattr(wifi, "channel");
	freq_24GHz = !strcmp(band, "2.4GHz");

	if (!channel || !strcmp(channel, "auto"))
		channel = freq_24GHz ? "6" : "149";

	/* Find all wifi-ap interfaces that reference this radio */
	rc = lyd_find_xpath(cif, "../interface[derived-from-or-self(type, 'infix-if-type:wifi-ap') and wifi/radio = current()/name]", &ap_interfaces);
	if (rc != LY_SUCCESS || !ap_interfaces || ap_interfaces->count == 0) {
		ERROR("No wifi-ap interfaces reference radio %s", ifname);
		return SR_ERR_OK;
	}

	/* The first AP interface becomes the main interface (radio gets renamed to this) */
	ap_interface = ap_interfaces->dnodes[0];
	main_interface_name = lydx_get_cattr(ap_interface, "name");

	ERROR("Generating hostapd config for radio %s, main interface %s with %d total APs",
		  ifname, ifname, ap_interfaces->count);

	/* Clean up any existing AP configuration */
	erasef(HOSTAPD_SUPPLICANT_CONF, ifname);

	hostapd_conf = fopenf("w", HOSTAPD_SUPPLICANT_CONF, ifname);
	if (!hostapd_conf) {
		ly_set_free(ap_interfaces, NULL);
		return SR_ERR_INTERNAL;
	}

	fprintf(hostapd_conf, "# Generated by Infix confd for radio %s (main interface %s)\n",
			ifname, main_interface_name);

	/* Basic hostapd configuration using the main AP interface name */
	fprintf(hostapd_conf,
		"interface=%s\n"
		"driver=nl80211\n"
		"hw_mode=%c\n"
		"wmm_enabled=1\n"
		"channel=%s\n"
		"logger_syslog=-1\n"
		"logger_syslog_level=0\n"
		"logger_stdout=0\n"
		"ctrl_interface=/var/run/hostapd\n"
		"ctrl_interface_group=0\n\n",
		main_interface_name, freq_24GHz ? 'g' : 'a', channel);

	if (strcmp(country, "00"))
		fprintf(hostapd_conf, "country_code=%s\n", country);

	if (freq_24GHz)
		fprintf(hostapd_conf, "ieee80211n=1\n");
	else
		fprintf(hostapd_conf, "ieee80211ac=1\n");

	/* Configure first AP interface as main SSID */
	struct lyd_node *main_wifi = lydx_get_child(ap_interface, "wifi");
	if (main_wifi) {
		const char *ssid = lydx_get_cattr(main_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(main_wifi, "secret");
		const char *encryption = lydx_get_cattr(main_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
		}

		fprintf(hostapd_conf, "\n# Main SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	/* Add additional AP interfaces as BSS entries */
	for (uint32_t i = 1; i < ap_interfaces->count; i++) {
		ap_interface = ap_interfaces->dnodes[i];
		const char *ap_ifname = lydx_get_cattr(ap_interface, "name");
		struct lyd_node *ap_wifi = lydx_get_child(ap_interface, "wifi");

		if (!ap_wifi) continue;

		const char *ssid = lydx_get_cattr(ap_wifi, "ssid");
		const char *secret_name = lydx_get_cattr(ap_wifi, "secret");
		const char *encryption = lydx_get_cattr(ap_wifi, "encryption");
		const char *secret = NULL;

		if (encryption && secret_name) {
			struct lyd_node *secret_node = lydx_get_xpathf(ap_interface,
				"../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret = lydx_get_cattr(secret_node, "cleartext-key");
			if (!secret) {
				ERROR("Could not retrieve secret key '%s' for BSS %s", secret_name, ap_ifname);
				continue;
			}
		}

		/* Add as BSS entry */
		fprintf(hostapd_conf, "\nbss=%s\n", ap_ifname);
		fprintf(hostapd_conf, "# SSID: %s\n", ssid);
		fprintf(hostapd_conf, "ssid=%s\n", ssid);

		if (encryption && !strcmp(encryption, "mixed-wpa2-wpa3") && secret) {
			fprintf(hostapd_conf, "wpa_key_mgmt=WPA-PSK SAE\n");
			fprintf(hostapd_conf, "wpa_passphrase=%s\n", secret);
			fprintf(hostapd_conf, "sae_password=%s\n", secret);
			fputs("wpa_pairwise=CCMP\n", hostapd_conf);
			fputs("rsn_pairwise=CCMP\n", hostapd_conf);
			fputs("ieee80211w=1\n", hostapd_conf);
			fputs("wpa=2\n", hostapd_conf);
		}
		fputs("ignore_broadcast_ssid=0\n", hostapd_conf);
	}

	ly_set_free(ap_interfaces, NULL);
	fclose(hostapd_conf);

	/* Generate init script for the main interface */
	hostapd_finit = dagger_fopen_net_init(net, main_interface_name, NETDAG_INIT_POST, "hostapd.sh");
	if (!hostapd_finit)
		return SR_ERR_INTERNAL;

	fprintf(hostapd_finit, "# Generated by Infix confd\n");
	fprintf(hostapd_finit, "if [ -f '/etc/finit.d/enabled/hostapd@%s.conf' ];then\n", ifname);
	fprintf(hostapd_finit, "initctl -bfqn touch hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "else\n");
	fprintf(hostapd_finit, "initctl -bfqn enable hostapd@%s\n", ifname);
	fprintf(hostapd_finit, "fi\n");
	fclose(hostapd_finit);

	return rc;
}

bool wifi_ap_must_delete(struct lyd_node *dif)
{

	struct lyd_node *cwifi;
	const char *radio_name;
	struct lyd_node *radio_dif;


	/* Get the wifi container from the current interface */
	cwifi = lydx_get_child(dif, "wifi");
	if (!cwifi)
		return false;

	/* Get the radio reference */
	radio_name = lydx_get_cattr(cwifi, "radio");
	if (!radio_name)
		return false;

	/* Look for the radio interface in dif to see if it's being deleted */
	radio_dif = lydx_get_xpathf(dif, "../interface[name='%s']", radio_name);
	if (radio_dif) {
		ERROR("%s must delete, radio change", lydx_get_cattr(dif, "name"));
		return true;
	}

	return false;
}

int wifi_gen_del(struct lyd_node *iface,  struct dagger *net)
{
	const char *ifname;
	FILE *fp;

	ifname = lydx_get_cattr(iface, "name");
	fp = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_PRE, "disable-wifi.sh");
	if (!fp) {
		ERROR("Failed to open disable-wifi.sh");
		return SR_ERR_INTERNAL;
	}
	/* Disable both station and AP services for this interface */
	disable_wifi_station(ifname, fp);
	disable_wifi_ap(ifname, fp);
	fclose(fp);
	return SR_ERR_OK;
}
