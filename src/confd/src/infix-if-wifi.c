/* SPDX-License-Identifier: BSD-3-Clause */
#include <srx/lyx.h>

#include "ietf-interfaces.h"

#define WPA_SUPPLICANT_FINIT_CONF "/etc/finit.d/available/wpa_supplicant-%s.conf"
#define WPA_SUPPLICANT_CONF       "/etc/wpa_supplicant-%s.conf"

static int wifi_gen_client_config(const char *ifname, const char *ssid, const char *country, const char *secret, const char* encryption, struct dagger *net, bool first)
{
	FILE *wpa_supplicant = NULL, *wpa = NULL;
	char *encryption_str;
	int rc = SR_ERR_OK;

	if (!secret && (ssid && country && encryption)) {
		/* Not an error, updated from two ways, interface cb and keystore cb. */
		return 0;
	}

	wpa = dagger_fopen_net_init(net, ifname, NETDAG_INIT_POST, "wpa_supplicant.sh");
	if (!wpa) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	fprintf(wpa, "# Generated by Infix confd\n");

	fprintf(wpa, "if [ -f '/etc/finit.d/enabled/wifi@%s.conf' ];then\n", ifname);
	fprintf(wpa, "initctl -bfqn touch wifi@%s\n", ifname);
	fprintf(wpa, "else\n");
	fprintf(wpa, "initctl -bfqn enable wifi@%s\n", ifname);
	fprintf(wpa, "fi\n");
	fclose(wpa);

	wpa_supplicant = fopenf("a+", WPA_SUPPLICANT_CONF, ifname);
	if (!wpa_supplicant) {
		rc = SR_ERR_INTERNAL;
		goto out;
	}

	if (!ssid || !secret) {
		fprintf(wpa_supplicant,
			"ctrl_interface=/run/wpa_supplicant\n"
			"autoscan=periodic:10\n"
			"ap_scan=1\n");
	} else {
		if (!encryption) {
			asprintf(&encryption_str, "key_mgmt=NONE");
		} else {
			asprintf(&encryption_str, "key_mgmt=SAE WPA-PSK\npsk=\"%s\"", secret);
		}
		if (first) {
			fprintf(wpa_supplicant,
				"country=%s\n"
				"ctrl_interface=/run/wpa_supplicant\n"
				"autoscan=periodic:10\n"
				"ap_scan=1\n\n", country);
		}
		fprintf(wpa_supplicant, "network={\n"
			"bgscan=\"simple: 30:-45:300\"\n"
			"ssid=\"%s\"\n"
			"%s\n"
			"}\n\n", ssid, encryption_str);
		free(encryption_str);
	}
	fclose(wpa_supplicant);

out:
	return rc;

}
int wifi_gen(struct lyd_node *dif, struct lyd_node *cif, struct dagger *net)
{
	const char *ssid_name, *secret_name, *secret, *ifname, *country, *encryption, *mode;
	struct lyd_node *wifi, *secret_node, *ssid;
	bool first = true;
	bool enabled;
	ifname      = lydx_get_cattr(cif, "name");
	enabled     = lydx_get_bool(cif, "enabled");

	if (!enabled)
		return wifi_gen_del(cif, net);

	wifi        = lydx_get_child(cif, "wifi");
	if (!wifi)
		return wifi_gen_del(cif, net);

	if (wifi && !lydx_get_child(wifi, "ssid")) { /* Only the precense container is set. */
		return wifi_gen_client_config(ifname, NULL, NULL, NULL, NULL, net, true);
	}
	country     = lydx_get_cattr(wifi, "country-code");
	mode        = lydx_get_cattr(wifi, "mode");


	if (!strcmp(mode, "client")) {
		erasef(WPA_SUPPLICANT_CONF, ifname);

		LYX_LIST_FOR_EACH(lyd_child(wifi), ssid, "ssid") {
			ssid_name   = lydx_get_cattr(ssid, "name");
			secret_name = lydx_get_cattr(ssid, "secret");
			encryption  = lydx_get_cattr(ssid, "encryption");
			secret_node = lydx_get_xpathf(cif, "../../keystore/symmetric-keys/symmetric-key[name='%s']", secret_name);
			secret      = lydx_get_cattr(secret_node, "cleartext-key");
			wifi_gen_client_config(ifname, ssid_name, country, secret, encryption, net, first);
			first = false;
		}
	}

	return SR_ERR_OK;
}

int wifi_gen_del(struct lyd_node *iface,  struct dagger *net)
{
	const char *ifname = lydx_get_cattr(iface, "name");
	FILE *iw = dagger_fopen_net_exit(net, ifname, NETDAG_EXIT_PRE, "iw.sh");

	fprintf(iw, "# Generated by Infix confd\n");
	fprintf(iw, "iw dev %s disconnect\n", ifname);
	fprintf(iw, "initctl -bfqn disable wifi@%s\n", ifname);
	fclose(iw);
	erasef(WPA_SUPPLICANT_CONF, ifname);

	return SR_ERR_OK;
}
