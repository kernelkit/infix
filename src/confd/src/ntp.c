/* SPDX-License-Identifier: BSD-3-Clause */

#include <assert.h>
#include <jansson.h>

#include <srx/common.h>
#include <srx/lyx.h>
#include <srx/srx_val.h>

#include "core.h"

#define XPATH_NTP_ "/ietf-ntp:ntp"
#define NTP_CONF   "/etc/chrony/conf.d/ntp-server.conf"
#define NTP_PREV   NTP_CONF "-"
#define NTP_NEXT   NTP_CONF "+"

static int change(sr_session_ctx_t *session, struct lyd_node *config, struct lyd_node *diff,
		  sr_event_t event, struct confd *confd)
{
	struct lyd_node *ntp, *entry, *makestep, *refclock;
	const char *port;
	FILE *fp;

	if (diff && !lydx_get_xpathf(diff, XPATH_NTP_))
		return SR_ERR_OK;

	switch (event) {
	case SR_EV_ENABLED:	/* first time, on register. */
	case SR_EV_CHANGE:	/* regular change (copy cand running) */
		/* Generate next config */
		break;

	case SR_EV_ABORT:	/* User abort, or other plugin failed */
		(void)remove(NTP_NEXT);
		return SR_ERR_OK;

	case SR_EV_DONE:
		/* Check if NTP container exists (presence container) */
		if (!lydx_get_xpathf(config, XPATH_NTP_)) {
			DEBUG("NTP server disabled, removing config");
			systemf("rm -f %s", NTP_CONF);

			return SR_ERR_OK;
		}

		/* Check if passed validation in previous event */
		if (!fexist(NTP_NEXT))
			return SR_ERR_OK;

		(void)remove(NTP_PREV);
		(void)rename(NTP_CONF, NTP_PREV);
		(void)rename(NTP_NEXT, NTP_CONF);

		/* Reload chronyd to pick up new config */
		if (systemf("chronyc reload sources >/dev/null 2>&1"))
			ERRNO("Failed reloading chronyd sources");

		systemf("initctl -nbq touch chronyd");
		return SR_ERR_OK;

	default:
		return SR_ERR_OK;
	}

	ntp = lydx_get_xpathf(config, XPATH_NTP_);
	if (!ntp)
		return SR_ERR_OK;

	fp = fopen(NTP_NEXT, "w");
	if (!fp) {
		ERROR("Failed creating %s: %s", NTP_NEXT, strerror(errno));
		return SR_ERR_SYS;
	}

	fprintf(fp, "# Generated by confd\n");
	fprintf(fp, "# This file configures chronyd as an NTP server\n\n");

	/* Port configuration (optional) */
	port = lydx_get_cattr(ntp, "port");
	if (port) {
		fprintf(fp, "# Custom NTP port\n");
		fprintf(fp, "port %d\n\n", atoi(port));
	}

	/* makestep configuration - allow clock stepping for fast initial sync */
	makestep = lydx_get_child(ntp, "makestep");
	if (makestep) {
		const char *threshold = lydx_get_cattr(makestep, "threshold");
		const char *limit = lydx_get_cattr(makestep, "limit");

		fprintf(fp, "# Allow clock stepping for fast initial sync\n");
		fprintf(fp, "makestep %.1f %d\n\n", atof(threshold), atoi(limit));
	}

	fprintf(fp, "# Upstream NTP servers and peers\n");
	LYX_LIST_FOR_EACH(lyd_child(ntp), entry, "unicast-configuration") {
		const char *address, *type, *minpoll, *maxpoll, *version, *srcport;
		const char *directive = NULL;
		bool prefer, burst, iburst;

		address = lydx_get_cattr(entry, "address");
		type    = lydx_get_cattr(entry, "type");
		minpoll = lydx_get_cattr(entry, "minpoll");
		maxpoll = lydx_get_cattr(entry, "maxpoll");
		version = lydx_get_cattr(entry, "version");
		srcport = lydx_get_cattr(entry, "port");
		prefer  = lydx_get_bool(entry, "prefer");
		burst   = lydx_get_bool(entry, "burst");
		iburst  = lydx_get_bool(entry, "iburst");

		if (type && strstr(type, "uc-server"))
			directive = "server";
		else if (type && strstr(type, "uc-peer"))
			directive = "peer";

		if (directive && address) {
			fprintf(fp, "%s %s", directive, address);
			if (srcport)
				fprintf(fp, " port %s", srcport);
			if (iburst)
				fprintf(fp, " iburst");
			if (burst)
				fprintf(fp, " burst");
			if (prefer)
				fprintf(fp, " prefer");
			if (minpoll)
				fprintf(fp, " minpoll %s", minpoll);
			if (maxpoll)
				fprintf(fp, " maxpoll %s", maxpoll);
			if (version)
				fprintf(fp, " version %s", version);
			fprintf(fp, "\n");
		}
	}
	fprintf(fp, "\n");

	/* Reference clock (local stratum) - fallback time source */
	refclock = lydx_get_child(ntp, "refclock-master");
	if (refclock) {
		int stratum = atoi(lydx_get_cattr(refclock, "master-stratum"));

		/* Only configure local clock if stratum is valid (1-15) */
		if (stratum >= 1 && stratum <= 15) {
			fprintf(fp, "# Local reference clock - fallback stratum %d source\n", stratum);
			fprintf(fp, "local stratum %d orphan\n\n", stratum);
		}
	}

	/*
	 * Enable NTP server mode - allow clients to query us
	 *
	 * Using 'allow' without arguments permits all clients.
	 * In a future version with access-rules support, we could
	 * restrict to specific subnets.
	 */
	fprintf(fp, "# Allow NTP clients to query this server\n");
	fprintf(fp, "allow\n\n");

	/*
	 * Enable RTC synchronization
	 *
	 * On Linux, the kernel will copy system time to the hardware RTC
	 * every 11 minutes when the clock is synchronized. This keeps the
	 * RTC accurate for the next boot, which is important for embedded
	 * systems without continuous network connectivity.
	 */
	fprintf(fp, "# Synchronize system time to hardware RTC\n");
	fprintf(fp, "rtcsync\n");

	fclose(fp);
	return SR_ERR_OK;
}

/*
 * Inference callback for NTP server configuration
 *
 * When a user creates the /ietf-ntp:ntp presence container without
 * any configuration, we infer sensible defaults:
 *
 * - refclock-master container (stratum defaults to 16 per YANG model)
 * - makestep with threshold 1.0 and limit 3 (fast initial sync for embedded)
 *
 * This provides a usable NTP server configuration with just 'edit ntp' + 'leave'.
 */
static int cand(sr_session_ctx_t *session, uint32_t sub_id, const char *module,
		const char *path, sr_event_t event, unsigned request_id, void *priv)
{
	sr_val_t inferred_container = { .type = SR_CONTAINER_PRESENCE_T };
	size_t cnt = 0;

	if (event != SR_EV_UPDATE && event != SR_EV_CHANGE)
		return SR_ERR_OK;

	/* Check if NTP container exists */
	if (srx_nitems(session, &cnt, XPATH_NTP_) || !cnt)
		return SR_ERR_OK;

	/* Check if refclock-master already configured */
	if (!srx_nitems(session, &cnt, XPATH_NTP_"/refclock-master") && cnt > 0)
		return SR_ERR_OK;

	/* Check if unicast-configuration already configured */
	if (!srx_nitems(session, &cnt, XPATH_NTP_"/unicast-configuration") && cnt > 0)
		return SR_ERR_OK;

	/* Infer refclock-master container (let YANG provide default stratum 16) */
	DEBUG("Inferring NTP refclock-master container");
	srx_set_item(session, &inferred_container, 0, XPATH_NTP_"/refclock-master");

	/* Infer makestep for fast initial sync (critical for embedded systems) */
	if (!srx_nitems(session, &cnt, XPATH_NTP_"/infix-ntp:makestep") || cnt == 0) {
		DEBUG("Inferring NTP makestep container");
		/* Create presence container (let YANG provide defaults: threshold 1.0, limit 3) */
		srx_set_item(session, &inferred_container, 0, XPATH_NTP_"/infix-ntp:makestep");
	}

	return SR_ERR_OK;
}

int ntp_change(sr_session_ctx_t *session, struct lyd_node *config,
	       struct lyd_node *diff, sr_event_t event, struct confd *confd)
{
	return change(session, config, diff, event, confd);
}

int ntp_cand(sr_session_ctx_t *session, uint32_t sub_id, const char *module,
	     const char *path, sr_event_t event, unsigned request_id, void *priv)
{
	return cand(session, sub_id, module, path, event, request_id, priv);
}

int ntp_candidate_init(struct confd *confd)
{
	int rc;

	REGISTER_CHANGE(confd->cand, "ietf-ntp", XPATH_NTP_ "//.", SR_SUBSCR_UPDATE,
			ntp_cand, confd, &confd->sub);

	return SR_ERR_OK;
fail:
	ERROR("init failed: %s", sr_strerror(rc));
	return rc;
}
