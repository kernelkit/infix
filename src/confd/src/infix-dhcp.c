/* SPDX-License-Identifier: BSD-3-Clause */

#include <assert.h>
#include <ctype.h>
#include <pwd.h>
#include <sys/utsname.h>
#include <sys/sysinfo.h>
#include <sys/types.h>

#include <srx/common.h>
#include <srx/lyx.h>
#include <srx/srx_module.h>
#include <srx/srx_val.h>

#include "core.h"
#define  ARPING_MSEC  1000
#define  MODULE       "infix-dhcp-client"
#define  XPATH        "/infix-dhcp-client:dhcp-client"

static const struct srx_module_requirement reqs[] = {
	{ .dir = YANG_PATH_, .name = MODULE, .rev = "2023-05-22" },
	{ NULL }
};

static char *ip_cache(const char *ifname)
{
	struct in_addr ina;
	char *ipcache;
	char buf[20];
	FILE *fp;

	if (!fexistf("/var/lib/misc/%s.cache", ifname))
		return NULL;

	fp = fopenf("r", "/var/lib/misc/%s.cache", ifname);
	if (!fp)
		return NULL;

	if (!fgets(buf, sizeof(buf), fp)) {
		fclose(fp);
		return NULL;
	}
	fclose(fp);
	chomp(buf);

	if (!inet_aton(buf, &ina)) {
		erasef("/var/lib/misc/%s.cache", ifname);
		return NULL;
	}

	ipcache = malloc(20);
	if (ipcache)
		snprintf(ipcache, 20, "-r %.15s", buf);

	return ipcache;
}

static char *hostname(char *str, size_t len)
{
	FILE *fp;
	int pos;

	fp = fopen("/etc/hostname", "r");
	if (!fp)
		return NULL;

	pos = snprintf(str, len, "-x str:");
	if (!fgets(&str[pos], len - pos, fp))
		str[0] = 0;
	fclose(fp);
	chomp(str);

	return str;
}

static char *os_name_version(char *str, size_t len)
{
	char buf[256];
	FILE *fp;

	if (!str || !len)
		return NULL;

	fp = fopen("/etc/os-relase", "r");
	if (!fp)
		return NULL;

	str[0] = 0;
	while (fgets(buf, sizeof(buf), fp)) {
		if (!strncmp(buf, "NAME=", 5))
			snprintf(str, len, "-V '%.32s ", &buf[5]);
		if (!strncmp(buf, "VERSION=", 8)) {
			strlcat(str, &buf[8], len);
			strlcat(str, "'", len);
			break;
		}
	}
	fclose(fp);

	if (strlen(str) > 0 && str[strlen(str) - 1] != '\'') {
		str[0] = 0;
		return NULL;
	}

	return str;
}

static char *dhcp_options(sr_session_ctx_t *session, const char *ifname)
{
	char xpath[sizeof(XPATH) + 50];
	sr_error_t rc = SR_ERR_OK;
	sr_val_t *values = NULL;
	char *options = NULL;
	size_t count = 0;

	snprintf(xpath, sizeof(xpath), XPATH "/client-if[if-name='%s']/options", ifname);
	rc = sr_get_items(session, xpath, 0, 0, &values, &count);
	if (rc != SR_ERR_OK) {
		ERROR("failed fetching DHCP options: %s", sr_strerror(rc));
		goto out;
	}

	for (size_t i = 0; i < count; ++i) {
		char *val = values[i].data.string_val;
		size_t len = strlen(val) + 5;
		char opt[len];

		snprintf(opt, len, "-O %s ", val);
		DEBUG("opt value[%zu]: %s", i, opt);
		if (options) {
			char *opts;

			opts = realloc(options, strlen(options) + len + 1);
			if (!opts) {
				ERROR("failed reallocating options: %s", strerror(errno));
				free(options);
				options = NULL;
				goto out;
			}

			options = strcat(opts, opt);
		} else
			options = strdup(opt);

		DEBUG("options %s", options);
	}

out:
	if (values)
		sr_free_values(values, count);

	return options;
}

static void add(sr_session_ctx_t *session, struct lyd_node *cfg, const char *ifname)
{
	const char *metric = lydx_get_cattr(cfg, "route-preference");
	const char *client_id = lydx_get_cattr(cfg, "client-id");
	char *args = NULL, *ipcache = NULL, *options = NULL;
	bool arping = lydx_is_enabled(cfg, "arping");
	char hostnm[300], vendor[128] = { 0 };
	const char *action = "disable";
	char do_arp[20] = { 0 };
	FILE *fp;

	if (arping)
		snprintf(do_arp, sizeof(do_arp), "-a%d", ARPING_MSEC);

	if (client_id && client_id[0]) {
		args = alloca(strlen(client_id) + 12);
		if (args)
			sprintf(args, "-C -x 61:'\"%s\"'", client_id);
	}

	options = dhcp_options(session, ifname);
	if (!options) {
		ERROR("failed extracting DHCP options for client %s, aborting!", ifname);
		goto err;
	}

	os_name_version(vendor, sizeof(vendor));
	hostname(hostnm, sizeof(hostnm));
	ipcache = ip_cache(ifname);

	fp = fopenf("w", "/etc/finit.d/available/dhcp-%s.conf", ifname);
	if (!fp) {
		ERROR("failed creating DHCP client %s: %s", ifname, strerror(errno));
		goto err;
	}

	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "metric=%s\n", metric);
	fprintf(fp, "service <!> name:dhcp :%s\\\n"
		"	[2345] udhcpc -f -p /run/dhcp-%s.pid -t 10 -T 3 -A 10 %s -S -R %s \\\n"
		"		-o %s \\\n"
		"       	-i %s %s %s %s \\\n"
		"		-- DHCP client @%s\n",
		ifname, ifname, do_arp, hostnm,
		options,
		ifname, args ?: "", ipcache ?: "", vendor, ifname);
	fclose(fp);
	action = "enable";
err:
	systemf("initctl -bfqn %s dhcp-%s", action, ifname);
	if (options)
		free(options);
	if (ipcache)
		free(ipcache);
}

static void del(const char *ifname)
{
	systemf("initctl -bfq delete dhcp-%s", ifname);
}

static int change(sr_session_ctx_t *session, uint32_t sub_id, const char *module,
		  const char *xpath, sr_event_t event, unsigned request_id, void *_confd)
{
	struct lyd_node *global, *diff, *cifs, *difs, *cif, *dif;
	sr_error_t       err = 0;
	sr_data_t       *cfg;
	int              ena = 0;

	switch (event) {
	case SR_EV_DONE:
		break;
	case SR_EV_CHANGE:
	case SR_EV_ABORT:
	default:
		return SR_ERR_OK;
	}

	err = sr_get_data(session, XPATH "//.", 0, 0, 0, &cfg);
	if (err)
		goto err_abandon;

	err = srx_get_diff(session, &diff);
	if (err)
		goto err_release_data;

	global = lydx_get_descendant(cfg->tree, "dhcp-client", NULL);
	ena    = lydx_is_enabled(global, "enabled");

	cifs = lydx_get_descendant(cfg->tree, "dhcp-client", "client-if", NULL);
	difs = lydx_get_descendant(diff, "dhcp-client", "client-if", NULL);

	/* find the modified one, delete or recreate only that */
	LYX_LIST_FOR_EACH(difs, dif, "client-if") {
		const char *ifname = lydx_get_cattr(dif, "if-name");

		if (lydx_get_op(dif) == LYDX_OP_DELETE) {
			del(ifname);
			continue;
		}

		LYX_LIST_FOR_EACH(cifs, cif, "client-if") {
			if (strcmp(ifname, lydx_get_cattr(cif, "if-name")))
				continue;

			if (!ena || !lydx_is_enabled(cif, "enabled"))
				del(ifname);
			else
				add(session, cif, ifname);
			break;
		}
	}

	lyd_free_tree(diff);
err_release_data:
	sr_release_data(cfg);
err_abandon:

	return err;
}

/*
 * YANG v1.1 doesn't support default values for leaf-list elements so
 * we use the same inference technique used for inteface types to set
 * a default list of sane options.
 */
static int infer_options(sr_session_ctx_t *session, const char *path)
{
	const char *opt[] = { "subnet", "router", "dns", "hostname", "domain",
		"broadcast", "ntpsrv", "address", "staticroutes" };
	char xpath[strlen(path) + 10];
	sr_error_t rc = SR_ERR_OK;
	sr_val_t *values = NULL;
	size_t count = 0;
	char *ptr;

	strlcpy(xpath, path, sizeof(xpath));
	ptr = strstr(xpath, "]/");
	if (!ptr)
		return SR_ERR_SYS;

	ptr[1] = 0;
	strlcat(xpath, "/options", sizeof(xpath));

	rc = sr_get_items(session, xpath, 0, 0, &values, &count);
	if (rc != SR_ERR_OK) {
		ERROR("sr_get_items failed: %s", sr_strerror(rc));
		goto out;
	}

	if (count > 0)
		goto done;

	for (size_t i = 0; i < NELEMS(opt); ++i) {
		rc = sr_set_item_str(session, xpath, opt[i], NULL, SR_EDIT_DEFAULT);
		if (rc != SR_ERR_OK) {
			ERROR("failed infering option[%zu] = %s: %s", i, opt[i], sr_strerror(rc));
			goto out;
		}
	}
done:
	for (size_t i = 0; i < count; ++i) {
		DEBUG("DHCP option[%zu]: %s", i, values[i].data.string_val);
	}
out:
	if (values)
		sr_free_values(values, count);

	return rc;
}

static int update(sr_session_ctx_t *session, uint32_t sub_id, const char *module,
		  const char *xpath, sr_event_t event, unsigned request_id, void *priv)
{
	sr_change_iter_t *iter;
	sr_change_oper_t op;
	sr_val_t *old, *new;
	sr_error_t err;

	switch (event) {
	case SR_EV_UPDATE:
	case SR_EV_CHANGE:
		break;
	default:
		return SR_ERR_OK;
	}

	err = sr_dup_changes_iter(session, XPATH "//*", &iter);
	if (err)
		return err;

	while (sr_get_change_next(session, iter, &op, &old, &new) == SR_ERR_OK) {
		switch (op) {
		case SR_OP_CREATED:
		case SR_OP_MODIFIED:
			break;
		default:
			continue;
		}

		infer_options(session, new->xpath);
	}

	sr_free_change_iter(iter);
	return SR_ERR_OK;
}

int infix_dhcp_init(struct confd *confd)
{
	int rc;

	rc = srx_require_modules(confd->conn, reqs);
	if (rc)
		goto fail;

	REGISTER_CHANGE(confd->session, MODULE, XPATH, 0, change, confd, &confd->sub);
	REGISTER_CHANGE(confd->session, MODULE, XPATH, SR_SUBSCR_UPDATE, update, confd, &confd->sub);
	return SR_ERR_OK;
fail:
	ERROR("init failed: %s", sr_strerror(rc));
	return rc;
}
