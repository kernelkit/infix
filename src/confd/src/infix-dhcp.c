/* SPDX-License-Identifier: BSD-3-Clause */

#include <assert.h>
#include <ctype.h>
#include <pwd.h>
#include <sys/utsname.h>
#include <sys/sysinfo.h>
#include <sys/types.h>

#include <srx/common.h>
#include <srx/lyx.h>
#include <srx/srx_module.h>
#include <srx/srx_val.h>

#include "core.h"
#define  ARPING_MSEC  1000

static const struct srx_module_requirement infix_dhcp_reqs[] = {
	{ .dir = YANG_PATH_, .name = "infix-dhcp-client", .rev = "2023-05-22" },
	{ NULL }
};

static void add(const char *ifname, bool arping, const char *client_id)
{
	const char *opts = "-O subnet -O router -O dns -O domain -O ntpsrv -O 121";
	char *args = NULL, *ipcache = NULL;
	char buf[256], vendor[128] = { 0 };
	char do_arp[20] = { 0 };
	FILE *fp, *xp;

	fp = fopenf("w", "/etc/finit.d/available/dhcp-%s.conf", ifname);
	if (!fp) {
		ERROR("failed creating DHCP client service for %s: %s",
		      ifname, strerror(errno));
		return;
	}

	if (arping)
		snprintf(do_arp, sizeof(do_arp), "-a%d", ARPING_MSEC);

	if (fexistf("/var/lib/misc/%s.cache", ifname)) {
		struct in_addr ina;

		xp = fopenf("r", "/var/lib/misc/%s.cache", ifname);
		if (!xp)
			goto nocache;

		if (!fgets(buf, sizeof(buf), xp)) {
			fclose(xp);
			goto nocache;
		}
		fclose(xp);
		chomp(buf);

		if (!inet_aton(buf, &ina)) {
			erasef("/var/lib/misc/%s.cache", ifname);
			goto nocache;
		}

		ipcache = alloca(20);
		if (ipcache)
			snprintf(ipcache, 20, "-r %.15s", buf);
	nocache:
	}

	xp = fopen("/etc/os-relase", "r");
	if (xp) {
		while (fgets(buf, sizeof(buf), xp)) {
			if (!strncmp(buf, "NAME=", 5))
				snprintf(vendor, sizeof(vendor), "-V '%.32s ", &buf[5]);
			if (!strncmp(buf, "VERSION=", 8)) {
				strlcat(vendor, &buf[8], sizeof(vendor));
				strlcat(vendor, "'", sizeof(vendor));
				break;
			}
		}
		fclose(xp);
	}

	xp = fopen("/etc/hostname", "r");
	if (xp) {
		int pos;

		pos = snprintf(buf, sizeof(buf), "-x hostname:");
		if (!fgets(&buf[pos], sizeof(buf) - pos, xp))
			buf[0] = 0;
		fclose(xp);
		chomp(buf);
	}

	if (client_id && client_id[0]) {
		args = alloca(strlen(client_id) + 12);
		if (args)
			sprintf(args, "-C -x 61:'\"%s\"'", client_id);
	}

	/*
	 * XXX: hard-coded metric for now.  Should be 100 + ifmetric,
	 * which in turn should be based on the iftype.  E.g., a WiFi
	 * interface should have a base metric of 500 while a plain
	 * Ethernet interface has a base metric of 0.  These are the
	 * defaults, a user should be able to override this all by a
	 * dhcp routing metric.
	 */
	fprintf(fp, "# Generated by Infix confd\n");
	fprintf(fp, "metric=100\n");
	fprintf(fp, "service <!> name:dhcp :%s\\\n"
		"	[2345] udhcpc -f -p /run/dhcp-%s.pid -t 10 -T 3 -A 10\\\n"
		"		%s -S -R %s -o %s -i %s %s %s %s\\\n"
		"		-- DHCP client @%s\n", ifname, ifname, do_arp,
		buf, opts, ifname, args ?: "", ipcache ?: "", vendor, ifname);
	fclose(fp);

	if (systemf("initctl -bfq enable dhcp-%s", ifname))
		ERROR("failed enabling DHCP client on %s", ifname);
}

static void del(const char *ifname)
{
	systemf("initctl -bfq delete dhcp-%s", ifname);
}

static int client_change(sr_session_ctx_t *session, uint32_t sub_id, const char *module,
                         const char *xpath, sr_event_t event, unsigned request_id, void *_confd)
{
	struct lyd_node *global, *diff, *cifs, *difs, *cif, *dif;
	sr_error_t       err = 0;
	sr_data_t       *cfg;
	int              ena = 0;

	switch (event) {
	case SR_EV_DONE:
		break;
	case SR_EV_CHANGE:
	case SR_EV_ABORT:
	default:
		return SR_ERR_OK;
	}

	err = sr_get_data(session, "/infix-dhcp-client:dhcp-client//.", 0, 0, 0, &cfg);
	if (err) {
		ERROR("DHCP client fail 1");
		goto err_abandon;
	}

	err = srx_get_diff(session, &diff);
	if (err)
		goto err_release_data;

	global = lydx_get_descendant(cfg->tree, "dhcp-client", NULL);
	ena    = lydx_is_enabled(global, "enabled");

	cifs = lydx_get_descendant(cfg->tree, "dhcp-client", "client-if", NULL);
	difs = lydx_get_descendant(diff, "dhcp-client", "client-if", NULL);

	/* find the modified one, delete or recreate only that */
	LYX_LIST_FOR_EACH(difs, dif, "client-if") {
		const char *ifname = lydx_get_cattr(dif, "if-name");

		if (lydx_get_op(dif) == LYDX_OP_DELETE) {
			del(ifname);
			continue;
		}

		LYX_LIST_FOR_EACH(cifs, cif, "client-if") {
			const char *cid = lydx_get_cattr(cif, "client-id");
			bool arping = lydx_is_enabled(cif, "arping");

			if (strcmp(ifname, lydx_get_cattr(cif, "if-name")))
				continue;

			if (!ena || !lydx_is_enabled(cif, "enabled"))
				del(ifname);
			else
				add(ifname, arping, cid);
			break;
		}
	}

	lyd_free_tree(diff);
err_release_data:
	sr_release_data(cfg);
err_abandon:

	return err;
}

int infix_dhcp_init(struct confd *confd)
{
	int rc;

	rc = srx_require_modules(confd->conn, infix_dhcp_reqs);
	if (rc)
		goto fail;

	REGISTER_CHANGE(confd->session, "infix-dhcp-client", "/infix-dhcp-client:dhcp-client",
	                0, client_change, confd, &confd->sub);
	return SR_ERR_OK;
fail:
	ERROR("init failed: %s", sr_strerror(rc));
	return rc;
}
