/*
 * Infix Containers YANG module
 */
module infix-containers {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:infix-containers";
  prefix infix-cont;

  import ietf-yang-types {
    prefix yang;
  }

  import ietf-interfaces {
    prefix if;
  }

  import ietf-inet-types {
    prefix inet;
  }

  import infix-interfaces {
    prefix infix-if;
  }

  revision 2023-12-14  {
    description "Initial revision";
    reference "internal";
  }

  /*
   * Typedefs
   */

  typedef restart-policy {
    type enumeration {
      enum no {
	description "Do not restart containers that exit/crash.";
	value 1;
      }
      enum retry {
	description "Restart containers up to 10 times before giving up.";
	value 2;
      }
      enum always {
	description "Always restart containers when they exit.";
	value 3;
      }
    }
  }

  /*
   * Data Nodes
   */

  container container {
    list container {
      key "name";

      leaf name {
	description "Name of the Docker container";
	type string;
      }

      leaf enabled {
	description "Enable or disable a container configuration.";
	type boolean;
	default true;
      }

      list env {
	description "Set environment variables, key=\"value\" pairs.";
	key key;

	leaf key {
	  description "Single word, [A-Za-z_]";
	  type string;
	}

	leaf value {
	  description "Argument to key can be a single word or quoted multiple words.";
	  mandatory true;
	  type string;
	}
      }

      leaf entrypoint {
	description "Override the default ENTRYPOINT from the image.";
	type string;
      }

      leaf hostname {
	description "Sets the container host name that is available inside the container.";
	type inet:domain-name;
      }

      leaf image {
	description "Docker image used for the container";
	mandatory true;
	type string;
      }

      leaf restart-policy {
	description "Restart policy to when containers exit/crash.";
	type restart-policy;
	default retry;
      }

      leaf manual {
	description "Auto-start or manual start after creation/reboot.";
	type boolean;
      }

      choice network {
	description "Select network mode: none, host, or container network interfaces.";

	case host-network {
	  leaf host-network {
	    description "Run in same network namespace as host.";
	    type boolean;
	  }
	}

	case network {
	  list network {
	    description "Container network interface to connect to the container.";
	    key name;

	    leaf name {
	      description "CNI network to connect to the container.";
	      type if:interface-ref;
	      must "/if:interfaces/if:interface[if:name = current()]/infix-if:container-network" {
		error-message "Container networks must be interfaces classified as container-network.";
	      }
	    }

	    leaf-list option {
	      description "Options for CNI bridges.
                           Example: ip=1.2.3.4 to request a specific IP, both IPv4 and IPv6.
                           interface_name=foo0 name to set interface name inside container.";
	      type string;
	    }
	  }

	  leaf-list publish {
	    description "Publish container port, or a range of ports, to the host.
                         Syntax: [[ip:][hostPort]:]containerPort[/protocol]
                         Sample: 8080:80           -- forward tcp port 8080 to container port 80
                                 69:69/udp         -- forward udp port 69 to container port 69
                                 127.0.0.1:8080:80 -- forward only from loopback interface";
	    type string;
	  }

	  leaf-list dns {
	    description "Set custom DNS servers, or 'none' to use /etc/resolv.conf in image.";
	    type string;
	  }

	  leaf-list search {
	    description "Set custom DNS search domains, or '.' to not set search domain.";
	    type string;
	  }
	}
      }

      leaf read-only {
	description "Create a read-only container.  Use volumes for writable directories.";
	type boolean;
      }

      list volume {
	description "Create a writable volume that survive container upgrades.

                     Volumes are retained over the lifetime of a container and survive
                     both upgrading the image as well as configuration changes, which
                     otherwise wipe the default writable layer a container is given.

                     Volumes combine well with 'read-only' containers, when you know
                     which files/directories you want to persist.";
	key name;

	leaf name {
	  description "Single word, [A-Za-z_], to identify this volume.
                       For example, a volume for /etc may be labled etc.

                       Note: will be prefixed with container name globally.";
	  type string;
	}

	leaf dir {
	  description "Directory to mount the volume on inside the container, e.g., /etc";
	  mandatory true;
	  type string;
	}
      }

      list file {
        description "Files to mount inside container.";
        key name;

        leaf name {
          description "File to store in host's startup-config as binary.

                       Note: will be prefixed with container name globally.";
          type string;
        }

        leaf path {
          description "Path to location inside container to mount file on, e.g., /etc/ntpd.conf";
          type string {
            pattern '/.*';
          }
        }

        leaf content {
          description "File contents, in base64 native format (XML/JSON).";
          type binary;
        }
      }

      container statistics {
	description "Statistics of the container";
	config false;

	leaf status {
	  description "Status of the Docker container";
	  type enumeration {
	    enum running;
	    enum stopped;
	  }
	}

	leaf created {
	  description "Creation timestamp of the container";
	  type yang:date-and-time;
	}
      }
    }
  }

  rpc container-pull {
    description "Upgrade (fetch) a container image";

    input {
      leaf image {
	description "Name of the container image to upgrade.";
	type string;
      }
    }
  }

  rpc container-stop {
    description "Stop a container";

    input {
      leaf name {
	description "Name of the container to stop";
	type string;
      }
    }
  }

  rpc container-start {
    description "Start a container";

    input {
      leaf name {
	description "Name of the container to start";
	type string;
      }
    }
  }
}
