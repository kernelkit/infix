#!/bin/sh
# Called from /etc/fstab to ensure we have something writable mounted
# at /cfg, /etc, /home, /root, and /var.
#
# /mnt/cfg is used to store device modifications made to /etc, /home,
# /root.
#
# /mnt/var is used as the backing store for /var.  If /mnt/var isn't
# available, /mnt/cfg will still be be used to persist /var/lib.
#
# If a disk partiion with the corresponding label ("cfg"/"var") is
# available, that is used to persist changes to the aforementioned
# directories. Otherwise fall back to a tmpfs based RAM disk. This
# effectively brings up the system with the default configuration, but
# obviously any subsequent configuration is ephemeral.
. /etc/os-release

set -e

nm=$(basename "$0")
err=0
opt="-k"

# External button or bootloader changed kernel command line
check_factory()
{
    if [ -f /mnt/cfg/infix/.reset ]; then
	return 0;
    fi

    if grep -q 'finit.cond=factory-reset' /proc/cmdline; then
	return 0;
    fi

    # Add to your br2-external to extend factory-reset check
    if [ ! -x /usr/libexec/infix/check-factory ]; then
	return 1;
    fi

    /usr/libexec/infix/check-factory
}

factory_reset()
{
    find /sys/class/leds/ -type l -exec sh -c 'echo 100 > $0/brightness' {} \;
    logger $opt -p user.crit -t "$nm" "Resetting to factory defaults."

    rm -rf /mnt/cfg/* /mnt/var/*

    logger $opt -p user.crit -t "$nm" "Factory reset complete."
    sync
}

is_rpi()
{
    [ -r /sys/firmware/devicetree/base/model ] || return 1

    model=$(cat /sys/firmware/devicetree/base/model 2>/dev/null | tr -d '\0')
    echo "$model" | grep -q "^Raspberry Pi"
}

wait_mmc()
{
    # Try up to 50 times with 0.2s sleep = 10 second timeout
    for _ in $(seq 50); do
        if ls /dev/mmcblk* >/dev/null 2>&1; then
            logger $opt -p user.notice -t "$nm" "MMC device available after delay"
            return 0
        fi
        sleep .2
    done

    logger $opt -p user.warn -t "$nm" "Timeout waiting for MMC device"
    return 1
}

# This early on we don't have the luxury of /dev/disk/by-label/$1
find_partition_by_label()
{
    label="$1"

    for diskpath in /sys/class/block/*; do
	devname=$(basename "$diskpath")
	[ -f "$diskpath/partition" ] && continue

	disk="/dev/$devname"
	result=$(sgdisk -p "$disk" 2>/dev/null | awk -v label="$label" -v devname="$devname" '
	    /^  *[0-9]/ {
		if ($7 == label) {
		    if (devname ~ /^(mmcblk|nvme|loop)/) {
			print devname "p" $1
		    } else {
			print devname $1
		    }
		    exit 0
		}
	    }
	')

	if [ -n "$result" ]; then
	    echo "$result"
	    return 0
	fi
    done
    return 1
}

# Expand the given partition to fill up the rest of storage (sdcard)
resize_by_label()
{
    label="$1"

    devname=$(find_partition_by_label "$label")
    if [ -z "$devname" ]; then
	logger $opt -p user.err -t "$nm" "Label \"$label\" not found"
	return 1
    fi

    part="/dev/$devname"
    diskname=$(basename "$(readlink -f "/sys/class/block/$devname/..")")
    disk="/dev/$diskname"
    partnum="${devname##*[^0-9]}"

    logger $opt -p user.notice -t "$nm" "Found partition $part (partition $partnum on $disk)"

    start=$(sgdisk -i "$partnum" "$disk" 2>/dev/null | grep "First sector:" | awk '{print $3}')
    if [ -z "$start" ]; then
	logger $opt -p user.err -t "$nm" "Could not determine start sector for partition $partnum"
	return 1
    fi

    printf "\r\033[K[ â‹¯  ] Resizing /var partition on sdcard, please wait ..." > /dev/console
    logger $opt -p user.notice -t "$nm" "Expanding partition $partnum from sector $start to end of disk"

    if ! sgdisk -e "$disk" 2>&1 | logger $opt -p user.notice -t "$nm"; then
	logger $opt -p user.warn -t "$nm" "Failed expanding GPT on $disk"
	return 1
    fi

    if ! sgdisk -d "$partnum" "$disk" >/dev/null 2>&1; then
	logger $opt -p user.warn -t "$nm" "Failed deleting partition $partnum on $disk"
	return 1
    fi

    if ! sgdisk -n "$partnum:$start:0" "$disk" >/dev/null 2>&1; then
	logger $opt -p user.warn -t "$nm" "Failed recreating partition $partnum on $disk"
	return 1
    fi

    if ! sgdisk -t "$partnum:8300" "$disk" >/dev/null 2>&1; then
	logger $opt -p user.warn -t "$nm" "Failed setting partition type on $disk"
	return 1
    fi

    if ! sgdisk -c "$partnum:$label" "$disk" >/dev/null 2>&1; then
	logger $opt -p user.warn -t "$nm" "Failed setting partition label on $disk"
	return 1
    fi

    logger $opt -p user.notice -t "$nm" "Partition table updated on $disk"
    partprobe "$disk" 2>/dev/null

    logger $opt -p user.notice -t "$nm" "Resizing filesystem on $part"
    if ! resize2fs "$part" 2>&1 | logger $opt -p user.notice -t "$nm"; then
	logger $opt -p user.warn -t "$nm" "Failed resizing filesystem on $part"
	return 1
    fi

    tune2fs -O resize_inode "$part" 2>/dev/null
    printf "\r\033[K[ \033[32mOK\033[0m ] Resizing /var partition on sdcard, done. Rebooting ...\n" > /dev/console
    logger $opt -p user.notice -t "$nm" "Partition expanded, rebooting to complete filesystem resize"

    reboot -f
}

mount_rw()
{
    # If something is already setup, leave it be.
    mountpoint -q "/$1" && return 0

    if [ "$1" = "var" ]; then
	if is_rpi && [ ! -e /mnt/aux/resized ] ; then
	    touch /mnt/aux/resized
	    resize_by_label "$1"
	fi
    fi

    # TODO: Also look for UBI partitions
    mount LABEL="$1" 2>/dev/null && return 0

    return 1
}

# Bind mount /var or /var/lib to ensure applications like podman can set
# up overlay mounts for containers.  Overlays cannot sit on top of other
# overlays.  We always copy the contents of /var or /var/lib from the
# rootfs to get updates, e.g., new packages added in an upgrade.
mount_bind()
{
    src="$1"
    dst="$2"

    mkdir -p "$src"
    cp -af "$dst/." "$src/" ||:

    mount -o bind "$src" "$dst"
}

# mkdir -p -m 0755 only applies to the deepest directory
# shellcheck disable=SC2174
mount_overlay()
{
    tag="$1"
    src="$2"
    dst="$3"
    u="$src/infix/$tag.u"
    w="$src/infix/$tag.w"

    mkdir -p -m 0755 "$u"
    mkdir -p -m 0755 "$w"

    # Ensure that all users in wheel can create the .reset file
    # on /cfg and upload docker images to /var
    chgrp wheel "$(dirname "$u")"

    mount -t overlay "$tag-overlay" "$dst" \
	  -o lowerdir="$dst",upperdir="$u",workdir="$w"
}

# Fall back to console logging if sysklogd is too old
if ! logger -? |grep -q "Log to kernel"; then
    opt="-c"
fi


# On Raspberry Pi, MMC controller may probe slowly, in particular if we
# netboot (ram load) the devcice wait for it
if is_rpi && ! ls /dev/mmcblk* >/dev/null 2>&1; then
    wait_mmc
fi

# The aux partition must be mounted before everything else since it's used
# for internal bookkeeping.
if ! mount_rw aux >/dev/null 2>&1; then
    logger $opt -p user.warn -t "$nm" \
	   "No auxiliary partition found, software updates not supported."
fi

varsrc=/mnt/var
if ! mount_rw var >/dev/null 2>&1; then
    logger $opt -p user.warn -t "$nm" \
	   "No persistent storage found for /var, only /var/lib is persisted."
    varsrc=/mnt/tmp/infix/var
    vlibsrc=/mnt/cfg/vlib
fi

cfgsrc=/mnt/cfg
etcsrc=/mnt/tmp
if ! mount_rw cfg >/dev/null 2>&1; then
    err=1

    logger $opt -p user.crit -t "$nm" \
	   "No persistent storage found for /cfg, falling back to tmpfs."

    cfgsrc=/mnt/tmp

    # Even if /mnt/var isn't available, if /mnt/cfg isn't either, then
    # there's no point in overlaying one ramdisk on top of another.
    vlibsrc=
fi

if check_factory; then
    factory_reset
fi

mount_overlay cfg  "$cfgsrc" /cfg
mount_overlay etc  "$etcsrc" /etc
mount_overlay home "$cfgsrc" /home
mount_overlay root "$cfgsrc" /root
mount_bind         "$varsrc" /var

[ -n "$vlibsrc" ] && mount_bind "$vlibsrc" /var/lib

for tag in $(ls /sys/bus/virtio/devices/*/mount_tag 2>/dev/null); do
    if [ "$(cat $tag | tr -d '\0')" = hostfs ]; then
	mount hostfs
	break
    fi
done

exit $err
