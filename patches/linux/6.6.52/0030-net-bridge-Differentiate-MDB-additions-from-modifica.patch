From 6d4c436335003259cc02a0f015fd3d1d54e988a2 Mon Sep 17 00:00:00 2001
From: Tobias Waldekranz <tobias@waldekranz.com>
Date: Thu, 16 May 2024 14:51:54 +0200
Subject: [PATCH 30/33] net: bridge: Differentiate MDB additions from
 modifications
Organization: Addiva Elektronik

Before this change, the reception of an IGMPv3 report (and analogously
for MLDv2) that adds a new group, would trigger two MDB RTM_NEWMDB
notifications from br_ip4_multicast_igmp3_report():

1. In br_ip4_multicast_add_group() when creating the entry
2. Directly at the end of br_ip4_multicast_igmp3_report(), as the new
   group is also deemed to be "changed"

The corresponding switchdev notifications generated by these present a
problem for drivers wanting to reference count group memberships,
since logically there is only a single reference to the group. Indeed,
when the membership eventually times out, only a single RTM_DELMDB is
generated.

Therefore, discriminate new groups from changes to existing groups by
introducing a RTM_SETMDB events to be used in the latter scenario.
---
 include/uapi/linux/rtnetlink.h | 2 ++
 net/bridge/br_mdb.c            | 4 ++--
 net/bridge/br_multicast.c      | 8 ++++----
 3 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index 51c13cf9c5ae..fbc8fd1d5f2c 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -134,6 +134,8 @@ enum {
 #define RTM_DELMDB RTM_DELMDB
 	RTM_GETMDB = 86,
 #define RTM_GETMDB RTM_GETMDB
+	RTM_SETMDB = 87,
+#define RTM_SETMDB RTM_SETMDB
 
 	RTM_NEWNSID = 88,
 #define RTM_NEWNSID RTM_NEWNSID
diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c
index 7305f5f8215c..a2882b126ecb 100644
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@ -724,7 +724,7 @@ static int br_mdb_replace_group_sg(const struct br_mdb_config *cfg,
 	else
 		del_timer(&pg->timer);
 
-	br_mdb_notify(cfg->br->dev, mp, pg, RTM_NEWMDB);
+	br_mdb_notify(cfg->br->dev, mp, pg, RTM_SETMDB);
 
 	return 0;
 }
@@ -945,7 +945,7 @@ static int br_mdb_replace_group_star_g(const struct br_mdb_config *cfg,
 	else
 		del_timer(&pg->timer);
 
-	br_mdb_notify(cfg->br->dev, mp, pg, RTM_NEWMDB);
+	br_mdb_notify(cfg->br->dev, mp, pg, RTM_SETMDB);
 
 	if (br_multicast_should_handle_mode(brmctx, cfg->group.proto))
 		br_multicast_star_g_handle_mode(pg, cfg->filter_mode);
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index 919abce8b5ac..36f510b1f96c 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -618,7 +618,7 @@ static void br_multicast_fwd_src_handle(struct net_bridge_group_src *src)
 		sg_mp = br_mdb_ip_get(src->br, &sg_key.addr);
 		if (!sg_mp)
 			return;
-		br_mdb_notify(src->br->dev, sg_mp, sg, RTM_NEWMDB);
+		br_mdb_notify(src->br->dev, sg_mp, sg, RTM_SETMDB);
 	}
 }
 
@@ -885,7 +885,7 @@ static void br_multicast_port_group_expired(struct timer_list *t)
 
 		if (WARN_ON(!mp))
 			goto out;
-		br_mdb_notify(br->dev, mp, pg, RTM_NEWMDB);
+		br_mdb_notify(br->dev, mp, pg, RTM_SETMDB);
 	}
 out:
 	spin_unlock(&br->multicast_lock);
@@ -2886,7 +2886,7 @@ static int br_ip4_multicast_igmp3_report(struct net_bridge_mcast *brmctx,
 			break;
 		}
 		if (changed)
-			br_mdb_notify(brmctx->br->dev, mdst, pg, RTM_NEWMDB);
+			br_mdb_notify(brmctx->br->dev, mdst, pg, RTM_SETMDB);
 unlock_continue:
 		spin_unlock(&brmctx->br->multicast_lock);
 	}
@@ -3028,7 +3028,7 @@ static int br_ip6_multicast_mld2_report(struct net_bridge_mcast *brmctx,
 			break;
 		}
 		if (changed)
-			br_mdb_notify(brmctx->br->dev, mdst, pg, RTM_NEWMDB);
+			br_mdb_notify(brmctx->br->dev, mdst, pg, RTM_SETMDB);
 unlock_continue:
 		spin_unlock(&brmctx->br->multicast_lock);
 	}
-- 
2.43.0

