From b27a65d5d5f6ffffbd2c26c1b5bea57a6de584d0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tom=C3=A1=C5=A1=20Pecka?= <tomas.pecka@cesnet.cz>
Date: Mon, 20 Oct 2025 18:46:38 +0200
Subject: [PATCH 3/7] wrap lyd_validate_op
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Organization: Wires

This patch wraps lyd_validate_op from libyang. Downstream users can now
validate operations (RPC input, replies, and notifications).

Change-Id: Ib03070bbc3e1d0dccd6bf38eda82e944db1093b1
Signed-off-by: Mattias Walstr√∂m <lazzer@gmail.com>
---
 include/libyang-cpp/DataNode.hpp |  2 +
 src/DataNode.cpp                 | 24 +++++++++++
 tests/context.cpp                |  2 +-
 tests/data_node.cpp              | 72 ++++++++++++++++++++++++++++++++
 tests/example_schema.hpp         | 22 ++++++++++
 5 files changed, 121 insertions(+), 1 deletion(-)

diff --git a/include/libyang-cpp/DataNode.hpp b/include/libyang-cpp/DataNode.hpp
index 50d6c0e..e202a96 100644
--- a/include/libyang-cpp/DataNode.hpp
+++ b/include/libyang-cpp/DataNode.hpp
@@ -59,6 +59,7 @@ template <typename Operation, typename Siblings>
 void handleLyTreeOperation(DataNode* affectedNode, Operation operation, Siblings siblings, std::shared_ptr<internal_refcount> newRefs);
 
 LIBYANG_CPP_EXPORT void validateAll(std::optional<libyang::DataNode>& node, const std::optional<ValidationOptions>& opts = std::nullopt);
+LIBYANG_CPP_EXPORT void validateOp(libyang::DataNode& input, const std::optional<libyang::DataNode>& opsTree, OperationType opType);
 
 LIBYANG_CPP_EXPORT Set<DataNode> findXPathAt(
         const std::optional<libyang::DataNode>& contextNode,
@@ -147,6 +148,7 @@ public:
     friend LIBYANG_CPP_EXPORT lyd_node* getRawNode(DataNode node);
 
     friend LIBYANG_CPP_EXPORT void validateAll(std::optional<libyang::DataNode>& node, const std::optional<ValidationOptions>& opts);
+    friend LIBYANG_CPP_EXPORT void validateOp(libyang::DataNode& input, const std::optional<libyang::DataNode>& opsTree, OperationType opType);
     friend LIBYANG_CPP_EXPORT Set<DataNode> findXPathAt(const std::optional<libyang::DataNode>& contextNode, const libyang::DataNode& forest, const std::string& xpath);
 
     bool operator==(const DataNode& node) const;
diff --git a/src/DataNode.cpp b/src/DataNode.cpp
index 7e87917..e28ef30 100644
--- a/src/DataNode.cpp
+++ b/src/DataNode.cpp
@@ -1226,6 +1226,30 @@ void validateAll(std::optional<libyang::DataNode>& node, const std::optional<Val
     }
 }
 
+/** @brief Validate op after parsing with lyd_parse_op.
+ *
+ * Wraps `lyd_validate_op`.
+ *
+ * @param input The tree with the op to validate.
+ * @param opsTree The optional data tree to validate the input against.
+ * @param opType The operation type. Contrary to `lyd_validate_op`, we accept not only YANG but also NETCONF and RESTCONF operation types (and internally convert them to YANG).
+ */
+void validateOp(libyang::DataNode& input, const std::optional<libyang::DataNode>& opsTree, OperationType opType)
+{
+    if (opType == OperationType::RpcYang || opType == OperationType::RpcRestconf || opType == OperationType::RpcNetconf) {
+        opType = OperationType::RpcYang;
+    } else if (opType == OperationType::ReplyYang || opType == OperationType::ReplyRestconf || opType == OperationType::ReplyNetconf) {
+        opType = OperationType::ReplyYang;
+    } else if (opType == OperationType::NotificationYang || opType == OperationType::NotificationRestconf || opType == OperationType::NotificationNetconf) {
+        opType = OperationType::NotificationYang;
+    } else {
+        throw Error("validateOp: DataYang datatype is not supported");
+    }
+
+    auto ret = lyd_validate_op(input.m_node, opsTree ? opsTree->m_node : nullptr, utils::toOpType(opType), nullptr);
+    throwIfError(ret, "libyang:validateOp: lyd_validate_op failed");
+}
+
 /** @short Find instances matching the provided XPath
  *
  * @param contextNode The node which serves as the "context node" for XPath evaluation. Use nullopt to start at root.
diff --git a/tests/context.cpp b/tests/context.cpp
index 6c5dde8..c0b7e09 100644
--- a/tests/context.cpp
+++ b/tests/context.cpp
@@ -154,7 +154,7 @@ TEST_CASE("context")
     {
         auto mod = ctx->parseModule(example_schema, libyang::SchemaFormat::YANG);
         auto rpcs = mod.actionRpcs();
-        REQUIRE(rpcs.size() == 1);
+        REQUIRE(rpcs.size() == 2);
         REQUIRE(rpcs[0].module().name() == "example-schema");
         REQUIRE(rpcs[0].name() == "myRpc");
 
diff --git a/tests/data_node.cpp b/tests/data_node.cpp
index db5a28e..9215b12 100644
--- a/tests/data_node.cpp
+++ b/tests/data_node.cpp
@@ -2430,6 +2430,78 @@ TEST_CASE("Data Node manipulation")
                         "Can't parse into operation data tree: LY_EVALID", libyang::Error);
             }
         }
+
+        DOCTEST_SUBCASE("Validation")
+        {
+            DOCTEST_SUBCASE("Valid input")
+            {
+                std::string rpcInput;
+                std::string rpcPath;
+                std::string expected;
+                std::optional<libyang::DataNode> depTree;
+
+                DOCTEST_SUBCASE("RPC")
+                {
+                    rpcInput = R"({"example-schema:input": { "number": 42 } })";
+                    rpcPath = "/example-schema:rpc-with-choice";
+                    expected = R"({
+  "example-schema:rpc-with-choice": {
+    "number": 42
+  }
+}
+)";
+                }
+
+                DOCTEST_SUBCASE("Action")
+                {
+                    rpcInput = R"({ "example-schema:input": { "friend": "Kuba" } })";
+                    rpcPath = "/example-schema:person[name='Franta']/poke-a-friend";
+                    expected = R"({
+  "example-schema:poke-a-friend": {
+    "friend": "Kuba"
+  }
+}
+)";
+                    depTree = ctx.newPath("/example-schema:person[name='Kuba']");
+                }
+
+                auto [parent, rpcTree] = ctx.newPath2(rpcPath);
+                auto rpcOp = rpcTree->parseOp(rpcInput, dataTypeFor(rpcInput), libyang::OperationType::RpcRestconf);
+
+                REQUIRE(!rpcOp.op);
+                REQUIRE(rpcOp.tree);
+
+                libyang::validateOp(*rpcTree, depTree, libyang::OperationType::RpcRestconf);
+                REQUIRE(*rpcTree->printStr(libyang::DataFormat::JSON, libyang::PrintFlags::KeepEmptyCont) == expected);
+            }
+
+            DOCTEST_SUBCASE("Nodes in disjunctive cases defined together")
+            {
+                auto rpcInput = R"({ "example-schema:input": { "number": 42, "text": "The ultimate answer" } })";
+
+                auto rpcTree = ctx.newPath("/example-schema:rpc-with-choice");
+                auto rpcOp = rpcTree.parseOp(rpcInput, dataTypeFor(rpcInput), libyang::OperationType::RpcRestconf);
+
+                REQUIRE(!rpcOp.op);
+                REQUIRE(rpcOp.tree);
+
+                REQUIRE_THROWS_WITH_AS(libyang::validateOp(rpcTree, std::nullopt, libyang::OperationType::RpcRestconf), "libyang:validateOp: lyd_validate_op failed: LY_EVALID", libyang::Error);
+            }
+
+            DOCTEST_SUBCASE("Action without the leafref node")
+            {
+                auto rpcInput = R"({ "example-schema:input": { "friend": "Kuba" } })";
+                auto rpcPath = "/example-schema:person[name='Franta']/poke-a-friend";
+
+                auto [parent, rpcTree] = ctx.newPath2(rpcPath);
+                auto rpcOp = rpcTree->parseOp(rpcInput, dataTypeFor(rpcInput), libyang::OperationType::RpcRestconf);
+
+                REQUIRE(!rpcOp.op);
+                REQUIRE(rpcOp.tree);
+
+                REQUIRE_THROWS_WITH_AS(libyang::validateOp(*rpcTree, std::nullopt, libyang::OperationType::RpcRestconf), "libyang:validateOp: lyd_validate_op failed: LY_EVALID", libyang::Error);
+            }
+        }
     }
 
     DOCTEST_SUBCASE("comparing") {
diff --git a/tests/example_schema.hpp b/tests/example_schema.hpp
index 02d3d74..acc6ecc 100644
--- a/tests/example_schema.hpp
+++ b/tests/example_schema.hpp
@@ -108,6 +108,16 @@ module example-schema {
         }
 
         action poke { }
+
+        action poke-a-friend {
+            input {
+                leaf friend {
+                    type leafref {
+                        path '../../../person/name';
+                    }
+                }
+            }
+        }
     }
 
     leaf bossPerson {
@@ -284,6 +294,18 @@ module example-schema {
             }
         }
     }
+    rpc rpc-with-choice {
+        input {
+            choice the-impossible-choice {
+              leaf text {
+                  type string;
+              }
+              leaf number {
+                  type int32;
+              }
+            }
+        }
+    }
 
     anydata myData {
     }
-- 
2.43.0

